import{b8 as e,b9 as t,bb as n,s,bP as r,c3 as i,y as o,bR as a,bT as l,b7 as d,c4 as c,c5 as h,c2 as u,c6 as p,c7 as f,c8 as b,c9 as v,ca as g}from"./card-b71c94d3.js";const m=document.createElement("template");m.innerHTML='<style>\n:host {\n  background-color: #ffffff;\n  width: 350px;\n  max-width: 75vw;\n\n  visibility: hidden;\n  transition: visibility 0.5s;\n}\n\n:host([open]) {\n  visibility: visible;\n}\n\n::slotted(div) {\n  box-sizing: border-box;\n}\n\n#d {\n  position: fixed;\n  z-index: 99;\n  background-color: inherit;\n  -webkit-overflow-scrolling: touch;\n  overflow: auto;\n  overscroll-behavior: contain;\n  backdrop-filter: var(--side-drawer-backdrop-filter, none);\n\n  top: 0;\n  bottom: 0;\n  left: 0;\n  height: 100%;\n  box-sizing: border-box;\n  transform: translateX(-100%);\n  transition: var(\n    --side-drawer-transition,\n    transform 0.25s ease-out\n  );\n  width: inherit;\n  max-width: inherit;\n  border-top-right-radius: inherit;\n  border-bottom-right-radius: inherit;\n}\n\n:host([open]) #d {\n  transform: none;\n  box-shadow: 0px 0px 25px 0px rgba(0, 0, 0, 0.5);\n}\n\n#fs {\n  position: fixed;\n  z-index: 98;\n  background-color: #000000;\n  backdrop-filter: var(--side-drawer-backdrop-filter, none);\n\n  top: 0;\n  bottom: 0;\n  right: -30px; /* hide scrollbar until overscroll bug is fixed */\n  height: 100vh;\n  transition: var(\n    --side-drawer-overlay-transition,\n    opacity linear 0.25s\n  );\n  width: calc(\n    100vw + 30px\n  ); /* put back to just 100vw once overscroll bug fixed */\n  opacity: 0;\n  visibility: hidden;\n\n  overflow: auto;\n  overscroll-behavior: contain;\n}\n\n:host([open]) #fs {\n  opacity: var(--side-drawer-overlay-opacity, 0.7);\n  visibility: visible;\n}\n\n/*\n   * Workaround for bug https://bugs.chromium.org/p/chromium/issues/detail?id=813094\n   * Once bug is fixed and in the wild we can remove this element and make #if overflow:hidden\n   * and set "right: 0; width: 100vw" for #fs\n   */\n#ifs {\n  height: calc(100vh + 1px);\n}\n</style>\n<div id="d"><slot></slot></div>\n<div id="fs"><div id="ifs"></div></div>\n';class w extends HTMLElement{constructor(){super();const e=this.attachShadow({mode:"open"});e.appendChild(m.content.cloneNode(!0)),this._freeSpaceDiv=e.getElementById("fs")}connectedCallback(){this._freeSpaceDiv&&this._freeSpaceDiv.addEventListener("click",this.handleFreeSpaceDivClick),this.upgradeProperty("open")}disconnectedCallback(){document.removeEventListener("keyup",this.handleKeyUp)}upgradeProperty(e){if(this.hasOwnProperty(e)){let t=this[e];delete this[e],this[e]=t}}handleKeyUp=e=>{if(!e.altKey&&"Escape"===e.key)e.preventDefault(),this.open=!1};get open(){return this.hasAttribute("open")}set open(e){e?this.hasAttribute("open")||this.setAttribute("open",""):this.hasAttribute("open")&&this.removeAttribute("open")}static get observedAttributes(){return["open"]}attributeChangedCallback(e,t,n){"open"===e&&(this.open?(this.setAttribute("tabindex","0"),this.setAttribute("aria-disabled","false"),this.focus({preventScroll:!0}),document.addEventListener("keyup",this.handleKeyUp),this.dispatchEvent(new CustomEvent("open",{bubbles:!0}))):(this.setAttribute("tabindex","-1"),this.setAttribute("aria-disabled","true"),document.removeEventListener("keyup",this.handleKeyUp),this.dispatchEvent(new CustomEvent("close",{bubbles:!0}))))}handleFreeSpaceDivClick=()=>{this.open=!1}}customElements.define("side-drawer",w);let y=class extends s{constructor(){super(...arguments),this.location="left",this.control=!0,this.open=!1,this.empty=!0,this._refDrawer=r(),this._refSlot=r(),this._resizeObserver=new ResizeObserver((()=>this._hideDrawerIfNecessary())),this._isHoverableDevice=i()}firstUpdated(e){super.firstUpdated(e);const t=document.createElement("style");t.innerHTML=":host {\n  width: unset;\n}\n\n#fs {\n  display: none;\n  width: 100%;\n  inset: 0;\n}\n\n#d,\n#fs {\n  height: 100%;\n  position: absolute;\n}\n\n#d {\n  overflow: visible;\n  max-width: 90%;\n}\n\n:host([location=right]) #d {\n  left: unset;\n  right: 0;\n  transform: translateX(100%);\n}\n\n:host([location=right][open]) #d {\n  transform: none;\n  box-shadow: var(--frigate-card-css-box-shadow, 0px 0px 25px 0px black);\n}\n\n#ifs {\n  height: 100%;\n}",this._refDrawer.value?.shadowRoot?.appendChild(t)}_slotChanged(){const e=this._refSlot.value?.assignedElements({flatten:!0});this._resizeObserver.disconnect();for(const t of e??[])this._resizeObserver.observe(t);this._hideDrawerIfNecessary()}_hideDrawerIfNecessary(){if(!this._refDrawer.value)return;const e=this._refSlot.value?.assignedElements({flatten:!0});this.empty=!e||!e.length||e.every((e=>{const t=e.getBoundingClientRect();return!t.width||!t.height}))}render(){return o`
      <side-drawer
        ${a(this._refDrawer)}
        location="${this.location}"
        ?open=${this.open}
        @mouseleave=${()=>{this.open&&(this.open=!1)}}
      >
        ${this.control?o`
              <div
                class="control-surround"
                @click=${e=>{l(e),this.open=!this.open}}
              >
                <ha-icon
                  class="control"
                  icon="${this.open?this.icons?.open??"mdi:menu-open":this.icons?.closed??"mdi:menu"}"
                  @mouseenter=${()=>{this._isHoverableDevice&&!this.open&&(this.open=!0)}}
                >
                </ha-icon>
              </div>
            `:""}
        <slot ${a(this._refSlot)} @slotchange=${()=>this._slotChanged()}></slot>
      </side-drawer>
    `}static get styles(){return d("side-drawer {\n  background-color: var(--card-background-color);\n}\n\ndiv.control-surround {\n  position: absolute;\n  bottom: 50%;\n  transform: translateY(50%);\n  z-index: 0;\n  padding-top: 20px;\n  padding-bottom: 20px;\n}\n\n:host([location=left]) div.control-surround {\n  padding-right: 12px;\n  left: 100%;\n}\n\n:host([location=right]) div.control-surround {\n  padding-left: 12px;\n  right: 100%;\n}\n\n:host([empty]), :host([empty]) > * {\n  visibility: hidden;\n}\n\n:host(:not([empty])), :host(:not([empty])) > * {\n  visibility: visible;\n}\n\nha-icon.control {\n  color: var(--secondary-color, white);\n  background-color: rgba(0, 0, 0, 0.7);\n  opacity: 0.5;\n  pointer-events: all;\n  --mdc-icon-size: 20px;\n  padding-top: 20px;\n  padding-bottom: 20px;\n  transition: opacity 0.5s ease;\n}\n\n:host([open]) ha-icon.control, ha-icon.control:hover {\n  opacity: 1;\n  background-color: black;\n}\n\n:host([location=left]) ha-icon.control {\n  border-top-right-radius: 20px;\n  border-bottom-right-radius: 20px;\n}\n\n:host([location=right]) ha-icon.control {\n  border-top-left-radius: 20px;\n  border-bottom-left-radius: 20px;\n}")}};e([t({attribute:!0,reflect:!0})],y.prototype,"location",void 0),e([t({attribute:!0,reflect:!0,type:Boolean})],y.prototype,"control",void 0),e([t({type:Boolean,reflect:!0,attribute:!0})],y.prototype,"open",void 0),e([t({attribute:!1})],y.prototype,"icons",void 0),e([t({type:Boolean,reflect:!0,attribute:!0})],y.prototype,"empty",void 0),y=e([n("frigate-card-drawer")],y);let _=class extends s{constructor(){super(...arguments),this._refDrawerLeft=r(),this._refDrawerRight=r(),this._boundDrawerHandler=this._drawerHandler.bind(this)}connectedCallback(){super.connectedCallback(),this.addEventListener("frigate-card:drawer:open",this._boundDrawerHandler),this.addEventListener("frigate-card:drawer:close",this._boundDrawerHandler)}disconnectedCallback(){super.disconnectedCallback(),this.removeEventListener("frigate-card:drawer:open",this._boundDrawerHandler),this.removeEventListener("frigate-card:drawer:close",this._boundDrawerHandler)}_drawerHandler(e){const t=e.detail.drawer,n=e.type.endsWith(":open");"left"===t&&this._refDrawerLeft.value?this._refDrawerLeft.value.open=n:"right"===t&&this._refDrawerRight.value&&(this._refDrawerRight.value.open=n)}render(){return o` <slot name="above"></slot>
      <slot></slot>
      <frigate-card-drawer
        ${a(this._refDrawerLeft)}
        location="left"
        .icons=${this.drawerIcons?.left}
      >
        <slot name="left"></slot>
      </frigate-card-drawer>
      <frigate-card-drawer
        ${a(this._refDrawerRight)}
        location="right"
        .icons=${this.drawerIcons?.right}
      >
        <slot name="right"></slot>
      </frigate-card-drawer>
      <slot name="below"></slot>`}static get styles(){return d(":host {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  overflow: hidden;\n}\n\n::slotted:not([name]) {\n  flex: 1;\n}")}};e([t({attribute:!1})],_.prototype,"drawerIcons",void 0),_=e([n("frigate-card-surround-basic")],_);var x=4;class k{constructor(e,t){this._results=null,this._resultsTimestamp=null,this._selectedIndex=null,e&&this.setResults(e),void 0!==t&&this.selectResult(t)}clone(){return c(this,x)}isSupersetOf(e){if(!this._results||!e._results)return!1;const t=new Set(this._results.map((e=>e.getID()))),n=new Set(e._results.map((e=>e.getID())));return!(!t||!n||t.has(null)||n.has(null))&&h(t,n)}getResults(){return this._results}getResultsCount(){return this._results?.length??0}hasResults(){return!!this._results}setResults(e){this._results=e,this._resultsTimestamp=new Date}getResult(e){return this._results&&void 0!==e?this._results[e]:null}getSelectedResult(){return null===this._selectedIndex?null:this.getResult(this._selectedIndex)}getSelectedIndex(){return this._selectedIndex}hasSelectedResult(){return null!==this.getSelectedResult()}resetSelectedResult(){return this._selectedIndex=null,this}getResultsTimestamp(){return this._resultsTimestamp}selectResult(e){return(null===e||this._results&&e>=0&&e<this._results.length)&&(this._selectedIndex=e),this}selectResultIfFound(e){for(const[t,n]of this._results?.entries()??[])if(e(n)){this._selectedIndex=t;break}return this}selectBestResult(e){if(this._results){const t=e(this._results);null!==t&&(this._selectedIndex=t)}return this}}const D=async(e,t,n,s,r,i)=>{const o=u(n,r.camera);if(!o)return;const a=R(n,s,o,{mediaType:i?.mediaType});a&&(await T(e,t,n,r,a,{targetView:i?.targetView,select:i?.select}))?.dispatchChangeEvent(e)},R=(e,t,n,s)=>{const r=t.performance?.features.media_chunk_size??p,i=e.generateDefaultEventQueries(n,{limit:r,..."clips"===s?.mediaType&&{hasClip:!0},..."snapshots"===s?.mediaType&&{hasSnapshot:!0}});return i?new f(i):null},E=async(e,t,n,s,r,i)=>{const o=u(n,r.camera);if(!o)return;const a=C(n,s,o);a&&(await T(e,t,n,r,a,{targetView:i?.targetView,select:i?.select}))?.dispatchChangeEvent(e)},C=(e,t,n,s)=>{const r=t.performance?.features.media_chunk_size??p,i=e.generateDefaultRecordingQueries(n,{limit:r,...s?.start&&{start:s.start},...s?.end&&{end:s.end}});return i?new b(i):null},T=async(e,t,n,s,r,i)=>{let o;const a=r.getQueries();if(!a)return null;try{o=await n.executeMediaQueries(t,a)}catch(t){return v(t),g(e,t),null}if(!o)return null;const l=new k(o,"latest"===i?.select&&o.length?o.length-1:void 0);let d={};return"time"===i?.select&&i?.targetTime&&(l.selectBestResult((e=>I(e,i.targetTime))),d={mediaViewer:{seek:i.targetTime}}),s?.evolve({query:r,queryResults:l,view:i?.targetView,camera:i?.targetCameraID}).mergeInContext(d)??null},I=(e,t,n)=>{let s;for(const[r,i]of e.entries())if(i.includesTime(t)){const e=i.getStartTime(),o=i.getEndTime();if(!n||!e||!o)return r;const a="end"===n?o.getTime()-t.getTime():t.getTime()-e.getTime();(!s||a<s.delta)&&(s={index:r,delta:a})}return s?s.index:null};export{k as M,E as a,C as b,D as c,T as e,I as f};
