blueprint:
  name: Itinerary tracker notification
  source_url: "https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/Extra/Automations/itinerary-tracker-notification.yaml"
  domain: automation
  author: etiennec78
  description: |-
    # Itinerary tracker notification 📍

    ## Description 📝
    A blueprint that **notifies** all selected users when another one is **driving home**

    ## Key Features 🌟
    * Companion app notifications 🔔
    * Travel time and ETA notification updates 🔁
    * On notification tap custom link 👆
    * Speakers TTS support 🔊
    * Adjustable notifications 💬

    ## More info ℹ️
    * Version : 1.1.0
    * Set up sensors : [click here](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md)
    * Flowchart : [click here](https://miro.com/app/board/uXjVMpH4Tno=/)
    * Github : [click here](https://github.com/etiennec78/Home-Automation/tree/master/Automatic%20Gate/Extra/Automations)
    * Discord : etiennec78
    [!["Buy Me A Coffee"](https://www.buymeacoffee.com/assets/img/custom_images/yellow_img.png)](https://www.buymeacoffee.com/etiennec78)
  homeassistant:
    min_version: 2025.4.0
  input:
    per_person_sensors:
      name: Per person sensors
      icon: mdi:account-multiple
      collapsed: true
      description: ⚠️ Please sort the sensors in the same order as their users
      input:
        persons:
          name: 👤 Users
          description: |-
            Each **user** which should be **tracked** or **notified** when an itinerary is in progress (same order)
          selector:
            entity:
              multiple: true
              filter:
                domain: person
        notify_devices:
          name: 💬 Notify devices
          description: |-
            Each [**device** to **notify**](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#notify-services-)
            *Note : Optional*
          default: []
          selector:
            device:
              multiple: true
              filter:
                integration: mobile_app
        driving_sensors:
          name: 🚗 Driving sensors
          description: |-
            Each **[driving sensor](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#driving-sensors-)** which should trigger the automation (same order)
            *Note : There can be less driving sensors than users to notify. Place users with driving sensors first.*
          selector:
            entity:
              multiple: true
              filter:
                domain:
                  - binary_sensor
                  - input_boolean
        travel_time_sensors:
          name: ✈️ Travel time sensors
          description: |-
            Each **[travel time sensor](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#travel-time-sensors-%EF%B8%8F)** monitoring each user **time left before arrival** (same order)
            *Note: Optional if "Track travel time" is set to false*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: sensor
                device_class: duration

    persons_to_notify:
      name: Persons to notify
      icon: mdi:bell-ring
      collapsed: true
      description: If notify everyone is disabled, the bluprint will check for any of these conditions per user
      input:
        notify_everyone:
          name: 🔔🧩 Notify everyone
          description: Should the automation notify everyone ?
          default: false
          selector:
            boolean:
        zones_to_notify:
          name: 🔔📍 Zones to notify
          description: Persons in these zones will be notified
          default:
            - zone.home
          selector:
            entity:
              multiple: true
              domain: zone
        notify_persons_away:
          name: 🔔🚪 Notify persons away
          description: Should the automation notify persons that are not in any zone ?
          default: false
          selector:
            boolean:
        notify_persons_driving:
          name: 🔔🚗 Notify persons driving
          description: Should the automation notify other drivers ?
          default: false
          selector:
            boolean:

    notification_settings:
      name: Notification settings
      icon: mdi:cog
      collapsed: true
      input:
        language:
          name: Notification language
          description: The **language** in which **notifications** will be sent to you
          default: "en"
          selector:
            language:
              languages:
                - en
                - fr
        custom_translations:
          name: Custom translations
          description: |-
            A **json** dictionary to change the default **notifications translations**
            *Note : You can find the translation keys in the strings['en'] variable in the code or in your traces*
          default: |-
            {
              "message": {}
            }
          selector:
            text:
              multiline: true
        notif_refresh_rate_ftn:
          name: 🔁 Notification refresh rate function
          description: |-
            The function used to calculate the **seconds** between two tracking notifications to lower your quota consumption
            *Note : {{remaining}} will be replaced by the seconds remaining until the arrival*
          default: "{{ max(10, (remaining)/4) }}"
          selector:
            template:
        on_tap_link:
          name: 👆 On tap link
          description: |-
            The **link** you will go to if you **tap** on the notification
            *Note : Can be Home Assistant relative links*
          default: "/lovelace/vehicle-tracker-map"
          selector:
            text:
        persistent_notification:
          name: 🔔 Persistent notification
          description: Show notifications in Home Assistant **[dashboard](https://www.home-assistant.io/integrations/persistent_notification)**
          default: false
          selector:
            boolean:

    speakers:
      name: Speakers
      icon: mdi:speaker-multiple
      collapsed: true
      input:
        speaker_tts_devices:
          name: 🔊 TTS speakers
          description: |-
            The **home speakers** your want to play TTS on
            *Note : Optional*
          default: []
          selector:
            entity:
              multiple: true
              domain: media_player
        speaker_tts_service:
          name: 🎙️ TTS service
          description: |-
            The **TTS service** you want to use for your speakers
            *Note : Optional*
          default: ""
          selector:
            target:
              entity:
                domain: tts
        drive_start_tts:
          name: 🚀 Drive start TTS
          description: Notify over TTS when someone starts driving
          default: True
          selector:
            boolean:
        nearly_arrived_tts:
          name: 🛬 Nearly arrived TTS
          description: Notify over TTS when the driver has nearly arrived
          default: True
          selector:
            boolean:
        driver_arrived_tts:
          name: 🏁 Arrived TTS
          description: Notify over TTS when the driver has arrived
          default: True
          selector:
            boolean:
        nearly_arrived_time:
          name: ⏱️ Nearly arrived time trigger
          description: The remaining time at which the automation will send a nearly arrived TTS
          default: 3
          selector:
            number:
              min: 0
              max: 60
              unit_of_measurement: minutes

variables:
  persons: !input persons
  notify_devices: !input notify_devices
  driving_sensors: !input driving_sensors
  travel_time_sensors: !input travel_time_sensors
  notify_everyone: !input notify_everyone
  zones_to_notify: !input zones_to_notify
  notify_persons_away: !input notify_persons_away
  notify_persons_driving: !input notify_persons_driving
  speaker_tts_devices: !input speaker_tts_devices
  speaker_tts_service: !input speaker_tts_service
  drive_start_tts: !input drive_start_tts
  nearly_arrived_tts: !input nearly_arrived_tts
  driver_arrived_tts: !input driver_arrived_tts
  nearly_arrived_time: !input nearly_arrived_time
  language: !input language
  custom_translations: !input custom_translations
  custom_translations_json: "{{ custom_translations | from_json }}"
  strings:
    en:
      message:
        itinerary_started: "{driver_name} just got into their car"
        itinerary_ongoing: "{driver_name} will arrive arround {arrival}"
        nearly_arrived: "{driver_name} will arrive in {remaining_minutes} minutes"
        driver_arrived: "{driver_name} just arrived home"
        unsupported_tt_integration: "Your travel time integration is not supported !"
    fr:
      message:
        itinerary_started: "{driver_name} vient de monter dans sa voiture"
        itinerary_ongoing: "{driver_name} arrivera vers {arrival}"
        nearly_arrived: "{driver_name} arrivera dans {remaining_minutes} minutes"
        driver_arrived: "{driver_name} vient d'arriver à la maison"
        unsupported_tt_integration: "Votre intégration de temps de trajet n'est pas supportée !"

triggers:
  - trigger: state
    entity_id: !input driving_sensors
    from: "off"
    to: "on"

conditions: []

actions:
  - alias: Store list index of driver, notification services, extract driver sensors, init variables
    variables:
      idx: "{{ driving_sensors.index(trigger.entity_id) }}"
      notify_services: |-
        {% set data = namespace(devices_list=[]) %}

          {% for notify_idx in range(notify_devices | length) %}
            {% if notify_idx != idx %}
              {% if notify_everyone
                or zones_to_notify
                  and notify_idx < persons | length
                  and is_state(persons[notify_idx],
                    zones_to_notify | map('state_attr', 'friendly_name') | list
                    + zones_to_notify | map('replace', 'zone.', '') | list
                  )

                or notify_persons_away
                  and notify_idx < persons | length
                  and is_state(persons[notify_idx], 'not_home')

                or notify_persons_driving
                  and notify_idx < driving_sensors | length
                  and is_state(driving_sensors[notify_idx], 'on')
              %}
                {% set data.devices_list = data.devices_list + [notify_devices[notify_idx]] %}
              {% endif %}
            {% endif %}
          {% endfor %}

        {{ data.devices_list | map('device_attr', 'name') | map('slugify') | map('regex_replace', '^', 'notify.mobile_app_') | list }}

      driving_sensor: "{{ driving_sensors[idx] }}"
      driver: "{{ persons[idx] }}"
      driver_name: "{{ state_attr(driver, 'friendly_name') }}"
      notification_tag: "{{ 'itinerary-tracker-' ~ this.context.id }}"
      persistent_id: "{{ 'persistent_' ~ this.context.id }}"
      persistent_active: !input persistent_notification
      next_refresh: 0
      remaining: 0
      nearly_arrived_sent: false
      last_arrival_timestamp: "{{ none }}"

  - alias: Only continue if driver not home
    condition: template
    value_template: "{{ not is_state(driver, 'home') }}"
  - alias: Get notification translation
    variables: &get_translation
      message_id: "itinerary_started"
      message_string: |-
        {# Custom translation #}
        {%
          if 'message' in custom_translations_json
          and message_id in custom_translations_json['message']
        %}
          {{ custom_translations_json['message'][message_id] }}

        {# Selected language #}
        {% elif message_id in strings[language]['message'] %}
          {{ strings[language]['message'][message_id] }}

        {# Fallback to english #}
        {% else %}
          {{ strings['en']['message'][message_id] }}
        {% endif %}
      message: |-
        {{
          message_string.format(
            driver_name=driver_name,
            arrival=arrival,
            remaining_minutes=remaining_minutes
          )
        }}
  - alias: Notify each user except the driver about itinerary start
    repeat:
      for_each: "{{ notify_services }}"
      sequence:
        - action: "{{ repeat.item }}"
          data:
            message: "{{ message }}"
            data:
              notification_icon: mdi:car
              tag: "{{ notification_tag }}"
              channel: Itinerary status
              sticky: true
              # Hack to retrieve notification service when dismissed
              confirmation: "{{ repeat.item }}"
              url: !input on_tap_link
              clickAction: !input on_tap_link
              alert_once: true
  - alias: Send an itinerary started persistent notification
    action: persistent_notification.create
    data:
      message: "{{ message }}"
      notification_id: "{{ persistent_id }}"
    enabled: !input persistent_notification
  - alias: If drive_start_tts enabled, someone home, tts devices and service are set
    if:
      - condition: template
        value_template: |-
          {{
            drive_start_tts
            and speaker_tts_devices != []
            and speaker_tts_service != ''
            and persons | select('is_state', 'home') | list != []
          }}
    then:
      - alias: Play TTS on each device
        repeat:
          for_each: "{{ speaker_tts_devices }}"
          sequence:
            - action: tts.speak
              data:
                cache: true
                media_player_entity_id: "{{ repeat.item }}"
                message: "{{ message }}"
              target: "{{ speaker_tts_service }}"
  - alias: If travel time sensors set
    if:
      condition: template
      value_template: "{{ travel_time_sensors != [] }}"
    then:
      - variables:
          travel_time_sensor: "{{ travel_time_sensors[idx] }}"
      - alias: Repeat while driver still driving
        repeat:
          while:
            - condition: template
              value_template: "{{ is_state(driving_sensor, 'on') }}"
          sequence:
            - alias: Wait for travel time update, vehicle left, or notification cleared
              wait_for_trigger:
                - trigger: event
                  id: travel_time
                  event_type: state_changed
                  event_data:
                    entity_id: "{{ travel_time_sensor }}"
                - trigger: template
                  id: vehicle_left
                  value_template: "{{ is_state(driving_sensor, 'off') }}"
                - trigger: event
                  id: notification_cleared
                  event_type: mobile_app_notification_cleared
                  event_data:
                    tag: "{{ notification_tag }}"
                - trigger: persistent_notification
                  id: persistent_cleared
                  notification_id: "{{ persistent_id }}"
                  update_type: removed
                  enabled: "{{ persistent_active }}"
              timeout:
                # Wait for the end of the cooldown, or for the nearly arrived TTS, or indefinitely
                seconds: |-
                  {% set values = [43200] %}

                  {# End of cooldown #}
                  {% if next_refresh > now() | as_timestamp %}
                    {% set values = values | union([next_refresh - now() | as_timestamp]) %}
                  {% endif %}

                  {# Nearly arrived TTS #}
                  {%
                    if nearly_arrived_tts
                    and not nearly_arrived_sent
                    and remaining > nearly_arrived_time*60
                  %}
                    {% set values = values | union([remaining - nearly_arrived_time*60]) %}
                  {% endif %}

                  {{ min(values) }}
            - alias: If triggered by a notification cleared
              if:
                condition: template
                value_template: "{{ wait.trigger.id in ['notification_cleared', 'persistent_cleared'] }}"
              then:
                - choose:
                    - alias: If triggered by a mobile notification cleared
                      conditions:
                        - condition: template
                          value_template: "{{ wait.trigger.id == 'notification_cleared' }}"
                      sequence:
                        - alias: Remove the notification service
                          variables:
                            notify_services: |-
                              {{ notify_services | difference([wait.trigger.event.data.confirmation]) }}
                    - alias: If triggered by a persistent notification cleared
                      conditions:
                        - condition: template
                          value_template: "{{ wait.trigger.id == 'persistent_cleared' }}"
                      sequence:
                        alias: Disable persistent notifications
                        variables:
                          persistent_active: false
                - alias: Stop if there are no more notification services
                  if:
                    - condition: template
                      value_template: "{{ notify_services | length == 0 and not persistent_active }}"
                  then:
                    - stop: No notification services remaining
            - alias: If travel time remaining needs to trigger nearly arrived TTS
              if:
                - condition: template
                  value_template: |-
                    {{ nearly_arrived_tts
                      and not nearly_arrived_sent
                      and next_refresh != 0
                      and remaining <= nearly_arrived_time*60
                      and speaker_tts_devices != []
                      and speaker_tts_service != ''
                      and persons | select('is_state', 'home') | list != []
                    }}
              then:
                - alias: Get TTS translation
                  variables:
                    message_id: "nearly_arrived"
                    <<: *get_translation
                - alias: Play TTS on each device
                  repeat:
                    for_each: "{{ speaker_tts_devices }}"
                    sequence:
                      - action: tts.speak
                        data:
                          cache: true
                          media_player_entity_id: "{{ repeat.item }}"
                          message: "{{ message }}"
                        target: "{{ speaker_tts_service }}"
                - alias: Mark nearly arrived TTS as already sent
                  variables:
                    nearly_arrived_sent: true
            - alias: Only continue loop if triggered by travel time update
              condition: template
              value_template: "{{ wait.trigger.id == 'travel_time' }}"
            - alias: Only continue loop if notifications not on cooldown
              condition: template
              value_template: "{{ next_refresh <= now() | as_timestamp }}"
            - alias: Calculate next refresh
              variables:
                cooldown: !input notif_refresh_rate_ftn
                next_refresh: "{{ now() | as_timestamp + cooldown }}"
            - alias: Calculate ETA
              variables:
                remaining: |-
                    {% if state_attr(travel_time_sensor, 'duration') != none %}
                      {{ state_attr(travel_time_sensor, 'duration') | float * 60 }}
                    {% elif state_attr(travel_time_sensor, 'unit_of_measurement') == "min" %}
                      {{ states(travel_time_sensor) | float * 60 }}
                    {% elif state_attr(travel_time_sensor, 'unit_of_measurement') == "s" %}
                      {{ states(travel_time_sensor) | float }}
                    {% else %}
                      {{ none }}
                    {% endif %}
            - alias: Stop if travel time integration is not supported
              if:
                - condition: template
                  value_template: "{{ remaining is none }}"
              then:
                - alias: Get notification translation
                  variables:
                    message_id: "unsupported_tt_integration"
                    <<: *get_translation
                - alias: Notify driver about unsupported integration
                  action: "{{ notify_service }}"
                  data:
                    notification_icon: mdi:alert-circle
                    tag: "{{ notification_tag }}"
                    channel: Itinerary status
                    data:
                      importance: high
                - stop: Travel time integration not supported
                  error: true
            - alias: Convert ETA to needed types
              variables:
                remaining_minutes: "{{ (remaining/60) | round }}"
                arrival_timestamp: "{{ as_timestamp(now()) + remaining }}"
                arrival: "{{ arrival_timestamp | timestamp_custom('%H:%M') }}"
            - alias: Do not send notification if the time of arrival did not change
              condition: template
              value_template: |-
                {# If the next notification will be sent near the arrival #}
                {% if arrival_timestamp - next_refresh < 120 %}
                  {# Refresh notification if eta differs by at least 5s #}
                  {{
                    (
                      last_arrival_timestamp | int
                      - arrival_timestamp | int
                    ) | abs < 5
                  }}
                {% else %}
                  {# Refresh notification if eta differs by at least 1min #}
                  {{
                    (last_arrival_timestamp / 60) | int
                    != (arrival_timestamp / 60) | int
                  }}
                {% endif %}
            - alias: Save the current time of arrival
              variables:
                last_arrival_timestamp: "{{ arrival_timestamp }}"
            - alias: Get notification translation
              variables:
                message_id: "itinerary_ongoing"
                <<: *get_translation
            - alias: Send ETA notification to each user
              repeat:
                for_each: "{{ notify_services }}"
                sequence:
                  - action: "{{ repeat.item }}"
                    data:
                      message: "{{ message }}"
                      data:
                        notification_icon: mdi:map-marker-account
                        tag: "{{ notification_tag }}"
                        channel: Itinerary status
                        sticky: true
                        # Hack to retrieve notification service when dismissed
                        confirmation: "{{ repeat.item }}"
                        url: !input on_tap_link
                        clickAction: !input on_tap_link
                        alert_once: true
                        timeout: "{{ remaining | int }}"
                        chronometer: true
                        when: "{{ arrival_timestamp | int }}"
            - alias: If persistent notifications are still active
              if:
                - condition: template
                  value_template: "{{ persistent_active }}"
              then:
                - alias: Update the persistent notification
                  action: persistent_notification.create
                  data:
                    message: "{{ message }}"
                    notification_id: "{{ persistent_id }}"
    else:
      - alias: Wait for user to leave vehicle
        wait_for_trigger:
          - trigger: template
            id: vehicle_left
            value_template: "{{ is_state(driving_sensor, 'off') }}"
  - alias: If driver arrived home
    if:
      condition: template
      value_template: "{{ is_state(driver, 'home') }}"
    then:
      - alias: Get notification translation
        variables:
          message_id: "driver_arrived"
          <<: *get_translation
      - alias: Send arrival notification to each user
        repeat:
          for_each: "{{ notify_services }}"
          sequence:
            - action: "{{ repeat.item }}"
              data:
                message: "{{ message }}"
                data:
                  notification_icon: mdi:home-map-marker
                  tag: "{{ notification_tag }}"
                  channel: Itinerary status
                  url: !input on_tap_link
                  clickAction: !input on_tap_link
                  timeout: 300
      - alias: If persistent notifications are still active
        if:
          - condition: template
            value_template: "{{ persistent_active }}"
        then:
          - alias: Update the persistent notification
            action: persistent_notification.create
            data:
              message: "{{ message }}"
              notification_id: "{{ persistent_id }}"
      - alias: If driver_arrived_tts enabled, someone is home, TTS devices and service are set
        if:
          - condition: template
            value_template: |-
              {{ driver_arrived_tts
                and speaker_tts_devices != []
                and speaker_tts_service != ''
                and persons | select('is_state', 'home') | list != []
              }}
        then:
          - alias: Play TTS on each device
            repeat:
              for_each: "{{ speaker_tts_devices }}"
              sequence:
                - action: tts.speak
                  data:
                    cache: true
                    media_player_entity_id: "{{ repeat.item }}"
                    message: "{{ message }}"
                  target: "{{ speaker_tts_service }}"
    else:
      - alias: Remove itinerary notification for each user
        repeat:
          for_each: "{{ notify_services }}"
          sequence:
            - action: "{{ repeat.item }}"
              data:
                message: clear_notification
                data:
                  tag: "{{ notification_tag }}"
mode: parallel
