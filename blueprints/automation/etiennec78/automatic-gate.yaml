blueprint:
  name: Automatic Gate
  source_url: "https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/automatic-gate.yaml"
  domain: automation
  author: etiennec78
  description: |-
    # Automatic Gate â›©ï¸

    ## Description ðŸ“
    **Modular** and **secure** gate automation that **opens your gate** upon leaving or arriving
    Makes managing your gate while driving easier : don't ever touch your screen or remote again
    Have your gate greet you when you arrive home and be ready for you
    Customize the options to tailor the system to your exact needs

    ## Key Features ðŸŒŸ
    * **Automatic Opening**: Your gate will open automatically when you drive home. No need to press any buttons ! ðŸ 
    * **Smart Navigation**: Directly open the gate when leaving home, or launch an itinerary when starting from outside ðŸš€
    * **Multi-User Support**: Manages up to 10 drivers simultaneously ðŸš—
    * **Collision Prevention**: Ensures the gate doesn't close on anyone arriving or leaving at the same time ðŸš§
    * **Security & Reliability**:
      * Precise Waze and ETA calculations to have your gate fully open exactly when you arrive home ðŸŽ¯
      * Real-time position tracking to adjust timing for traffic or if you pass by without entering ðŸ“
      * Car status monitoring to cancel everything if you leave your car âœ‹
      * Built-in timeouts in case of an internet loss â³
      * Maximum entry and leaving time before auto-closing âŒ›
      * Notification alerts at each decision of the automation ðŸš¨
      * Manual actions prioritized over the automation, letting you control your gate even while the automation is running âœï¸
    * **Customizable Settings**:
      * Auto-close with iBeacon ðŸ“¡
      * Adjustable notifications ðŸ’¬
      * Customizable security options ðŸ”’
      * Customizable gate operation timings ðŸ› ï¸
      * Customizable travel time refresh rate ðŸ”
      * Multiple gates supported by reusing the blueprint â™»ï¸

    ## More info â„¹ï¸
    * Version : 1.1.0
    * Set up sensors : [click here](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md)
    * Flowchart : [click here](https://miro.com/app/board/uXjVMpH4Tno=/)
    * Github : [click here](https://github.com/etiennec78/Home-Automation/tree/master/Automatic%20Gate)
    * Discord : etiennec78
    [!["Buy Me A Coffee"](https://www.buymeacoffee.com/assets/img/custom_images/yellow_img.png)](https://www.buymeacoffee.com/etiennec78)
  homeassistant:
    min_version: 2025.4.0
  input:
    essential_inputs:
      name: Essential inputs
      icon: "mdi:gate"
      collapsed: true
      input:
        gate:
          name: â›©ï¸ Gate
          description: The **switch** or **cover** which controls your **[gate](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#gate-%EF%B8%8F)**
          selector:
            entity:
              multiple: true
              filter:
                domain:
                  - switch
                  - cover
        gate_location:
          name: ðŸ“ Gate location
          description: The zone where your gate is located, to detect whether you are leaving or arriving
          default: "zone.home"
          selector:
            entity:
              filter:
                domain: zone
        lead_time:
          name: ðŸ•“ Lead time
          description: The **lead time** to open the gate **before your arrival** (take your gate movement time & a margin into account)
          default: 75
          selector:
            number:
              min: 10
              max: 300
              unit_of_measurement: seconds

    per_person_sensors:
      name: Per person sensors
      icon: mdi:account-multiple
      collapsed: true
      description: |-
        âš ï¸ Please enter the same amount of entires in each input, and place users in the same order
      input:
        persons:
          name: ðŸ‘¤ Tracked users
          description: |-
            Each **user** which should be **[tracked](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#gps-location-trackers-)** for **position updates**
            *Notes :*
            *âš ï¸ Use high precision while driving in your ETA zone or you could time out*
            *If your tracker has report latency (wifi/ble), and you plug Android Auto just after leaving, your gate could open thinking you are still there*
          selector:
            entity:
              multiple: true
              filter:
                domain:
                  - device_tracker
                  - person
        driving_sensors:
          name: ðŸš— Driving sensors
          description: Each **[driving sensor](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#driving-sensors-)** which should trigger the automation
          selector:
            entity:
              multiple: true
              filter:
                domain:
                  - binary_sensor
                  - input_boolean
        travel_time_sensors:
          name: âœˆï¸ Travel time sensors
          description: |-
            Each **[travel time sensor](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#travel-time-sensors-%EF%B8%8F)** monitoring each user **time left before arrival**
            *âš ï¸ Please set a [custom polling interval](https://www.home-assistant.io/integrations/waze_travel_time/#defining-a-custom-polling-interval)*
          selector:
            entity:
              multiple: true
              filter:
                domain: sensor
                device_class: duration
        notify_devices:
          name: ðŸ’¬ Notify devices
          description: Each [**device** to **notify**](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#notify-services-)
          selector:
            device:
              multiple: true
              filter:
                integration: mobile_app
        itinerary_sensors:
          name: ðŸ—ºï¸ Itinerary sensors
          description: Each empty **[itinerary input text](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#itinerary-sensors-%EF%B8%8F)** helper to store each user **itinerary state**
          selector:
            entity:
              multiple: true
              filter:
                domain: input_text

    travel_time_settings:
      name: Travel time settings
      icon: mdi:timer
      collapsed: true
      input:
        activation_zone:
          name: ðŸ”’ Gate activation zone
          description: |-
            At which **distance** from the gate should the automation start estimating when to **open your gate** ?
            Note: It will automatically **close** if you **leave** this zone
          default: 500
          selector:
            number:
              min: 300
              max: 5000
              unit_of_measurement: meters
        travel_time_rate:
          name: ðŸ”„ Travel time refresh rate
          description: |-
            Calculate the Travel time & ETA

              - **Continuously** during the whole itinerary (custom refresh interval while away)
              - Only while the vehicle is **near home**
              - Only **once** when the vehicle gets near home
              - Listen to **external** sensor updates

            **"Continuously"** can use more Waze/Maps credits, but can be useful to display a precise ETA on your dashboard when far from your destination
            **"While near home"** allows to monitor if you drive near your gate without entering to abort the itinerary, or if there are traffic jams near home to open later (recommended)
            **"Only once"** uses the less amount of credits, but could trigger if you come near your gate without entering (not recommended)
            **"Listen for updates"** is made for vehicles providing their own travel time sensor. Do not use with an external travel time provider (e.g: Waze, Maps, Here)
          default: "near-home"
          selector:
            select:
              options:
                - label: Continuously
                  value: "continuous"
                - label: While near home
                  value: "near-home"
                - label: Once when near home
                  value: "once"
                - label: Listen for updates
                  value: "listen"
        continuously_refresh_interval:
          name: â³ Continuously refresh interval
          description: Your travel time **refresh interval** while away. Only active with a refresh rate set to **"Continuously"**
          default: 5
          selector:
            number:
              min: 1
              max: 60
              unit_of_measurement: minutes

    gate_behavior:
      name: Gate behavior
      icon: mdi:brain
      collapsed: true
      input:
        departure_opening_behavior:
          name: ðŸ›«ðŸ”“ Departure opening behavior
          description: |-
            Automatic gate **opening** behavior on **departure**

              - **Fully automatic** : Your gate will automatically open
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to open your gate
              - **Disabled** : Your gate will stay closed
          default: "auto"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        departure_closing_behavior:
          name: ðŸ›«ðŸ”’ Departure closing behavior
          description: |-
            Automatic gate **closing** behavior on **arrival**

              - **Fully automatic** : Your gate will automatically close
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to close your gate
              - **Disabled** : Your gate won't close automatically
          default: "timer"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        suggest_closing_after:
          name: ðŸ”’ Suggest closing after
          description: The time the gate will wait before **suggesting to close** on departure if you are using a **notification request** but don't have a sensor to detect your absence
          default: 120
          selector:
            number:
              min: 1
              max: 600
              unit_of_measurement: seconds
        arrival_opening_behavior:
          name: ðŸ›¬ðŸ”“ Arrival opening behavior
          description: |-
            Gate automatic **opening** behavior on **arrival**

              - **Fully automatic** : Your gate will automatically open
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to open your gate
              - **Disabled** : Your gate will stay closed
          default: "auto"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        arrival_closing_behavior:
          name: ðŸ›¬ðŸ”’ Arrival closing behavior
          description: |-
            Gate automatic **closing** behavior on **arrival**

              - **Fully automatic** : Your gate will automatically close
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to close your gate
              - **Disabled** : Your gate won't close automatically
          default: "auto"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        timer:
          name: â±ï¸ Cancelable timer time
          description: The time before the gate automatically opens/closes in "cancelable timer" mode without your input
          default: 5
          selector:
            number:
              min: 1
              max: 20
              unit_of_measurement: seconds

    security_features:
      name: Security features
      icon: mdi:security
      collapsed: true
      input:
        safety_delay:
          name: ðŸ”’ Auto-close safety delay
          description: The time the gate will wait before **automatically closing** if your gate is open but you still haven't left or arrived
          default: 5
          selector:
            number:
              min: 2
              max: 30
              unit_of_measurement: minutes
        timeout_delay:
          name: âŒ› Timeout delay
          description: |-
            The time the automation will wait before **stopping** if your phone **times out** and doesn't send new position updates, while being in the activation zone
            *Note : If your position provider doesn't let you use a high accuracy mode (like iOS), please increase this value*
          default: 2
          selector:
            number:
              min: 0.5
              max: 30
              unit_of_measurement: minutes
        forbidden_zones:
          name: â›” Forbidden zones
          description: If you enter any of these zones while driving home, your itinerary will be canceled
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: zone

    notification_settings:
      name: Notification settings
      icon: mdi:bell
      collapsed: true
      input:
        language:
          name: Notification language
          description: The **language** in which **notifications** will be sent to you
          default: "en"
          selector:
            language:
              languages:
                - en
                - fr
        custom_translations:
          name: Custom translations
          description: |-
            A **json** dictionary to change the default **notifications translations**
            *Note : You can find the translation keys in the strings['en'] variable in the code or in your traces*
          default: |-
            {
              "title": {},
              "message": {},
              "button": {}
            }
          selector:
            text:
              multiline: true
        phone_tts:
          name: ðŸ“³ Phone TTS
          description: Read notifications **aloud** on **Android** phones
          default: false
          selector:
            boolean:
        tts_text:
          name: ðŸ’¬ TTS text
          description: The **content** of the TTS
          default: "{{ title[:-2] ~ message }}"
          selector:
            template:

    presence_sensors:
      name: Presence sensors
      icon: mdi:leak
      collapsed: true
      input:
        wifi_devices:
          name: ðŸ  WiFi devices
          description: |-
            Each driver's WiFi device tracker
            *Note : Please place user sensors in the same order*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: device_tracker
        ble_entities:
          name: ðŸ”Ž iBeacon tracker entities
          description: |-
            Each **[BLE rssi tracker entity](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#bluetooth-entities-)** to monitor your distance from the gate
            *Note : Please place user sensors in the same order*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: sensor
                device_class: signal_strength
        ble_transmitter_entities:
          name: ðŸ“¡ iBeacon transmitter entities
          description: |-
            Each **[BLE transmitter entity](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#bluetooth-transmitter-)** to restore previous iBeacon transmitter power settings when iBeacon is not needed anymore
            *Notes : Let empty if you use iOS, or only use iBeacon for this automation*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                integration: mobile_app
                domain: sensor
                device_class: enum
        ble_scanner_switch:
          name: â¯ï¸ iBeacon scanner activator switch
          description: |-
            The **[switch](https://github.com/etiennec78/Home-Automation/blob/master/Automatic%20Gate/sensors.md#bluetooth-scanner-switch-)** to automatically **start and stop iBeacon scanning** when needed
            *Note : Leave empty if you want your iBeacon scanner to be always on*
          default: ""
          selector:
            entity:
              filter:
                domain: switch
        only_open_near:
          name: ðŸ  Only open on departure while connected to
          description: |-
            Should your gate only open if you are connected to WiFi/iBeacon while leaving ?
            *Notes :*
            *Useful for preventing your gate from opening if you are parked in front of your house*
            *WiFi can be slow to report new states*
          default: []
          selector:
            select:
              multiple: true
              options:
                - label: WiFi
                  value: wifi
                - label: iBeacon
                  value: ble
        only_open_near_timeout:
          name: âŒ› 'Only open while connected to' timeout
          description: The time the gate will wait for you to connect to WiFi/iBeacon before canceling the departure
          default: 10
          selector:
            number:
              min: 0
              max: 1800
              unit_of_measurement: seconds
        close_when_disconnected_from:
          name: ðŸ“¡ Close on departure when disconnected from
          description: Close the gate if driver's iBeacon is out of range
          default: []
          selector:
            select:
              multiple: true
              options:
                - label: iBeacon
                  value: ble

    locks:
      name: Door locks
      icon: mdi:door-closed-lock
      collapsed: true
      input:
        locks:
          name: ðŸ” Locks
          description: |-
            The **locks** that open your home's **doors**
            *Note : They will lock on exit once the gate is closed, and unlock once the vehicle has arrived and been turned off*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: lock
        dont_lock_if_people_remaining:
          name: ðŸ  Do not lock if there are still people home
          description: |-
            Avoid locking locks if some person entities are still in the gate zone besides yourself
            Note : if you drive away with multiple people, they might still be detected home and prevent locking
          default: false
          selector:
            boolean:

variables:
  gate: !input gate
  gate_location: !input gate_location
  lead_time: !input lead_time
  safety_delay: !input safety_delay
  timeout_delay: !input timeout_delay
  persons: !input persons
  driving_sensors: !input driving_sensors
  travel_time_sensors: !input travel_time_sensors
  notify_devices: !input notify_devices
  notify_services: "{{ notify_devices | map('device_attr', 'name') | map('slugify') | map('regex_replace', '^', 'notify.mobile_app_') | list }}"
  itinerary_sensors: !input itinerary_sensors
  travel_time_rate: !input travel_time_rate
  continuously_refresh_interval: !input continuously_refresh_interval
  activation_zone: !input activation_zone
  suggest_closing_after: !input suggest_closing_after
  timer: !input timer
  language: !input language
  custom_translations: !input custom_translations
  default_custom_translations: |-
    {
      "title": {},
      "message": {},
      "button": {}
    }
  custom_translations_json: "{{ custom_translations | from_json(none) }}"
  ble_entities: !input ble_entities
  ble_scanner_switch: !input ble_scanner_switch
  ble_transmitter_entities: !input ble_transmitter_entities
  only_open_near: !input only_open_near
  close_when_disconnected_from: !input close_when_disconnected_from
  wifi_devices: !input wifi_devices
  forbidden_zones: !input forbidden_zones
  dont_lock_if_people_remaining: !input dont_lock_if_people_remaining
  quick_tt_updates: 0
  last_quick_tt_update: "{{ none }}"
  failed_updates: 0
  strings:
    en:
      title:
        itinerary_started: "Itinerary started ðŸ"
        open_gate: "Open gate ? ðŸ”“"
        close_gate: "Close gate ? ðŸ”’"
        timer_opening: "Gate opening in {{timer}}s ðŸ”“"
        timer_closing: "Gate closing in {{timer}}s ðŸ”’"
        itinerary_canceled: "Itinerary canceled âŒ"
        awaiting: "Gate awaiting {awaited_persons} ðŸ’¤"
        disabled: "Automatic Gate disabled ðŸš«"
        invalid_config: "Invalid configuration ðŸ› ï¸"
      message:
        leaving_home: "You are leaving home"
        vehicle_started: "You have started your vehicle"
        soon_arrived: "You will arrive soon"
        arrived: "You have arrived"
        closing_suggestion: "{{suggest_closing_after}} seconds have passed"
        ble_out_of_range: "Your iBeacon is out of range"
        awaiting: "The gate will close once all users have entered/exited"
        vehicle_stopped: "You have left your vehicle"
        canceling_order: "You have pressed the cancel button"
        did_not_leave: "The vehicle did not leave in less than {{safety_delay}} minutes"
        did_not_arrive: "The vehicle did not arrive in less than {{safety_delay}} minutes"
        timed_out: "Your position has not been updated in {{timeout_delay}} minutes"
        vehicle_away: "The vehicle is not in the activation zone"
        travel_time_did_not_respond: "Your travel time integration did not respond during your itinerary"
        not_home: "You were not detected at home"
        triggered_frequently: "The blueprint is being triggered repeatedly !"
        disabled_triggered_frequently: |-
          The blueprint has been triggered {consecutive_errors} times in a row
          Please enable the blueprint manually once the issue has been fixed
        disabled_updated_frequently: |-
          The automation spammed the travel time API with requests too quickly
          Please report this issue on GitHub !
        forbidden_zone: "You entered a forbidden zone"
        invalid_travel_time_sensor: "Your travel time sensor does not exist !"
        unsupported_tt_integration: "Your travel time integration is not supported !"
        too_close: "You have started driving too close to the gate zone"
        invalid_translations: "Your custom translations are not valid !"
      button:
        open: "Open"
        close: "Close"
        cancel: "Cancel"
    fr:
      title:
        itinerary_started: "ItinÃ©raire dÃ©marrÃ© ðŸ"
        open_gate: "Ouvrir portail ? ðŸ”“"
        close_gate: "Fermer portail ? ðŸ”’"
        timer_opening: "Ouverture portail dans {{timer}}s ðŸ”“"
        timer_closing: "Fermeture portail dans {{timer}}s ðŸ”’"
        itinerary_canceled: "ItinÃ©raire annulÃ© âŒ"
        awaiting: "Portail en attente de {awaited_persons} ðŸ’¤"
        disabled: "Automatic Gate dÃ©sactivÃ© ðŸš«"
        invalid_config: "Configuration invalide ðŸ› ï¸"
      message:
        leaving_home: "Vous sortez de la maison"
        vehicle_started: "Vous avez dÃ©marrÃ© votre vÃ©hicule"
        soon_arrived: "Vous arrivez bientÃ´t"
        arrived: "Vous Ãªtes arrivÃ©"
        closing_suggestion: "{{suggest_closing_after}} secondes se sont Ã©coulÃ©es"
        ble_out_of_range: "Votre iBeacon est hors de portÃ©e"
        awaiting: "Le portail se refermera une fois tous les conducteurs entrÃ©s/sortis"
        vehicle_stopped: "Le vÃ©hicule a Ã©tÃ© arrÃªtÃ©"
        canceling_order: "Vous avez appuyÃ© sur le bouton annuler"
        did_not_leave: "Le vÃ©hicule n'est pas sorti en moins de {{safety_delay}} minutes"
        did_not_arrive: "Le vÃ©hicule n'est pas arrivÃ© en moins de {{safety_delay}} minutes"
        timed_out: "Votre position n'a pas Ã©tÃ© mise Ã  jour ces {{timeout_delay}} derniÃ¨res minutes"
        vehicle_away: "Le vÃ©hicule n'est pas dans la zone d'ouverture"
        travel_time_did_not_respond: "Votre intÃ©gration de temps de trajet n'a pas renvoyÃ© de valeur"
        not_home: "Le vÃ©hicule n'est pas Ã  la maison"
        triggered_frequently: "L'automatisation se dÃ©clenche Ã  rÃ©pÃ©tition !"
        disabled_triggered_frequently: |-
          L'automation s'est dÃ©clenchÃ©e {consecutive_errors} fois d'affilÃ©e
          RÃ©activez l'automatisation manuellement une fois le problÃ¨me corrigÃ©
        disabled_updated_frequently: |-
          L'automatisation a saturÃ© l'API de temps de trajet avec des requÃªtes trop rapides
          Signalez ce problÃ¨me sur GitHub svp !
        forbidden_zone: "Vous Ãªtes entrÃ© dans une zone interdite"
        invalid_travel_time_sensor: "Votre capteur de temps de trajet n'existe pas !"
        unsupported_tt_integration: "Votre intÃ©gration de temps de trajet n'est pas supportÃ©e !"
        too_close: "Vous avez dÃ©marrÃ© trop prÃ¨s de la zone du portail"
        invalid_translations: "Vos traductions personnalisÃ©es ne sont pas valides !"
      button:
        open: "Ouvrir"
        close: "Fermer"
        cancel: "Annuler"

triggers:
  - alias: Trigger when user connects to vehicle
    trigger: state
    entity_id: !input driving_sensors
    from: "off"
    to: "on"

conditions: []

actions:
  - if:
      - condition: template
        value_template: "{{ custom_translations_json is none }}"
    then:
      - variables:
          custom_translations_json: "{{ default_custom_translations }}"
      - alias: Set title and message ids
        variables:
          title_id: "invalid_config"
          message_id: "invalid_translations"
      - alias: Get notification translation
        variables: &get_translation
          title_string: |-
            {# Custom translation #}
            {%
              if 'title' in custom_translations_json
              and title_id in custom_translations_json['title']
            %}
              {{ custom_translations_json['title'][title_id] }}

            {# Selected language #}
            {% elif title_id in strings[language]['title'] %}
              {{ strings[language]['title'][title_id] }}

            {# Fallback to english #}
            {% else %}
              {{ strings['en']['title'][title_id] }}
            {% endif %}
          title: |-
            {{
              title_string.format(
                awaited_persons=awaited_persons
              )
            }}
          message_string: |-
            {# Custom translation #}
            {%
              if 'message' in custom_translations_json
              and message_id in custom_translations_json['message']
            %}
              {{ custom_translations_json['message'][message_id] }}

            {# Selected language #}
            {% elif message_id in strings[language]['message'] %}
              {{ strings[language]['message'][message_id] }}

            {# Fallback to english #}
            {% else %}
              {{ strings['en']['message'][message_id] }}
            {% endif %}
          message: |-
            {{
              message_string.format(
                consecutive_errors=consecutive_errors
              )
            }}
      - alias: Notify driver that his config is invalid
        action: "{{ notify_service }}"
        data:
          title: "{{ title }}"
          message: "{{ message }}"
          data:
            notification_icon: mdi:hammer-wrench
            channel: Automatic Gate config
            tag: invalid-config
            ttl: 0
      - sequence: &tts
          - alias: Notify over TTS
            action: "{{ notify_service }}"
            data:
              message: TTS
              data:
                tts_text: !input tts_text
                channel: Itinerary status
                importance: high
                ttl: 0
                media_stream: "alarm_stream"
            enabled: !input phone_tts
      - alias: Notify all users on the dashboard that the config is invalid
        action: persistent_notification.create
        data:
          title: "{{ title }}"
          message: "{{ message }}"
  - alias: Store list index of driver, extract driver sensors
    variables:
      idx: "{{ driving_sensors.index(trigger.entity_id) }}"
      person: "{{ persons[idx] }}"
      driving_sensor: "{{ trigger.entity_id }}"
      travel_time_sensor: "{{ travel_time_sensors[idx] }}"
      notify_service: "{{ notify_services[idx] }}"
      itinerary_sensor: "{{ itinerary_sensors[idx] }}"
      opening_order_id: "{{ 'opening_order_' ~ this.context.id }}"
      closing_order_id: "{{ 'closing_order_' ~ this.context.id }}"
      canceling_order_id: "{{ 'canceling_order_' ~ this.context.id }}"
  - alias: Stop if blueprint is triggered frequently
    if:
      - alias: If blueprint triggered less than 2 minutes ago
        condition: template
        value_template: "{{ states[itinerary_sensor].last_updated + timedelta(minutes=2) > now() }}"
      - alias: If driver in activation zone
        condition: template
        value_template: &activation_zone_in_condition |-
          {% if state_attr(person, 'gps_accuracy') is none %}
            {% set accuracy = 100 %}
          {% else %}
            {% set accuracy = state_attr(person, 'gps_accuracy') %}
          {% endif %}
          {% set gate_distance = distance(person, gate_location)*1000 - accuracy %}

          {{ gate_distance < activation_zone }}
    then:
      - alias: Get how many times the error occurred in a row
        variables:
          consecutive_errors: |-
            {% set sensor_value = states(itinerary_sensor) %}
            {% if sensor_value[:29] == 'error: triggered_frequently: ' %}
              {% if sensor_value[29:] | is_number %}
                {{ sensor_value[29:] | int + 1 }}
              {% else %}
                1
              {% endif %}
            {% else %}
              1
            {% endif %}
      - alias: Reset itinerary last_updated attribute
        action: input_text.set_value
        target:
          entity_id: "{{ itinerary_sensor }}"
        data:
          value: "error: triggered_frequently: {{ consecutive_errors }}"
      - choose:
          - alias: If this is the first time the error occurs in a row
            conditions:
              - condition: template
                value_template: "{{ consecutive_errors == 1 }}"
            sequence:
              - alias: Set notification ids
                variables:
                  title_id: "itinerary_canceled"
                  message_id: "triggered_frequently"
              - alias: Get notification translation
                variables: *get_translation
              - alias: Log error
                action: system_log.write
                data:
                  level: error
                  message: "{{ message }}"
                  logger: blueprints.etiennec78.automatic_gate
              - alias: Notify driver that the blueprint is being triggered frequently
                action: "{{ notify_service }}"
                data:
                  title: "{{ title }}"
                  message: "{{ message }}"
                  data: &notification_data
                    car_ui: true
                    notification_icon: mdi:alert-circle
                    channel: Itinerary status
                    importance: high
                    ttl: 0
                    push:
                      sound:
                        name: "default"
                        critical: 1
                    tag: itinerary-status
                    timeout: 300
              - sequence: *tts
          - alias: If this is the third time the error occurs in a row
            conditions:
              - condition: template
                value_template: "{{ consecutive_errors == 3 }}"
            sequence:
              - alias: Set error id
                variables:
                  message_id: "disabled_triggered_frequently"
              - alias: Disable the blueprint
                sequence: &disable_blueprint
                  - alias: Get title id
                    variables:
                      title_id: "disabled"
                  - alias: Get notification translation
                    variables: *get_translation
                  - alias: Log error
                    action: system_log.write
                    data:
                      level: error
                      message: "{{ message }}"
                      logger: blueprints.etiennec78.automatic_gate
                  - alias: Notify driver that the blueprint is disabling itself
                    action: "{{ notify_service }}"
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                      data: *notification_data
                  - sequence: *tts
                  - alias: Notify all users on the dashboard that the blueprint has disabled itself
                    action: persistent_notification.create
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                  - alias: Disable the blueprint
                    action: automation.turn_off
                    target:
                      entity_id: "{{ this.entity_id }}"
      - stop: Blueprint triggered too frequently
        error: true
  - alias: If driver at gate location
    if:
      - condition: template
        value_template: "{{ is_state(person, [state_attr(gate_location, 'friendly_name'), states[gate_location].object_id]) }}"
    then:
      #####################
      # OPEN GATE ON EXIT #
      #####################

      - alias: If driver has iBeacon entity set for auto-closing
        if:
          - condition: template
            value_template: "{{ (ble_entities | length) - 1 >= idx }}"
        then:
          - alias: Save iBeacon states
            variables:
              old_ibeacon_transmitter_states: |-
                {% if (ble_transmitter_entities | length) - 1 >= idx %}
                  {{ {
                    'state': states(ble_transmitter_entities[idx])
                      if states(ble_transmitter_entities[idx]) == 'Stopped' else none,
                    'transmit_power': (state_attr(ble_transmitter_entities[idx], 'Transmitting power') | regex_replace('([a-z])([A-Z])', '\\1_\\2') | lower)
                      if state_attr(ble_transmitter_entities[idx], 'Transmitting power') != 'high' else none,
                    'advertise_mode': (state_attr(ble_transmitter_entities[idx], 'Advertise mode') | regex_replace('([a-z])([A-Z])', '\\1_\\2') | lower)
                      if state_attr(ble_transmitter_entities[idx], 'Advertise mode') != 'lowLatency' else none
                  } }}
                {% else %}
                  {{ none }}
                {% endif %}
          - alias: If driver has a saved iBeacon transmitter state
            if:
              - condition: template
                value_template: "{{ old_ibeacon_transmitter_states != none }}"
            then:
              - alias: Change iBeacon state if needed
                if:
                  - condition: template
                    value_template: "{{ old_ibeacon_transmitter_states['state'] != none }}"
                then:
                  - action: "{{ notify_service }}"
                    data:
                      message: command_ble_transmitter
                      data:
                        command: turn_on
              - alias: Change iBeacon transmitting power if needed
                if:
                  - condition: template
                    value_template: "{{ old_ibeacon_transmitter_states['transmit_power'] != none }}"
                then:
                  - action: "{{ notify_service }}"
                    data:
                      message: command_ble_transmitter
                      data:
                        command: ble_set_transmit_power
                        ble_transmit: ble_transmit_high
              - alias: Change iBeacon advertise mode if needed
                if:
                  - condition: template
                    value_template: "{{ old_ibeacon_transmitter_states['advertise_mode'] != none }}"
                then:
                  - action: "{{ notify_service }}"
                    data:
                      message: command_ble_transmitter
                      data:
                        command: ble_set_advertise_mode
                        ble_advertise: ble_advertise_low_latency
          - alias: Activate iBeacon scanner if switch set
            if:
            - condition: template
              value_template: "{{ ble_scanner_switch != '' and is_state(ble_scanner_switch, 'off') }}"
            then:
              - action: switch.turn_on
                target:
                  entity_id: "{{ ble_scanner_switch }}"
      - alias: If driver chose to wait for iBeacon or WiFi before opening to ensure that vehicle is not parked outside
        if:
          - condition: template
            value_template: |-
              {{
                'wifi' in only_open_near and (wifi_devices | length) - 1 >= idx
                or 'ble' in only_open_near and (ble_entities | length) - 1 >= idx
              }}
        then:
          - alias: Wait for iBeacon or WiFi to report home
            wait_template: |-
              {{
                not is_state(ble_entities[idx], 'unknown')
                or is_state(wifi_devices[idx], 'home')
                or is_state(driving_sensor, 'off')
              }}
            continue_on_timeout: true
            timeout: !input only_open_near_timeout
          - alias: If an error occured
            if:
              - condition: template
                value_template: |-
                  {{
                    wait.remaining == 0
                    or is_state(driving_sensor, 'off')
                  }}
            then:
              - alias: Set error id
                variables:
                  message_id: |-
                    {{ wait.remaining == 0 | iif('not_home', 'vehicle_stopped') }}
              - alias: Create error
                sequence: &create_error
                  - alias: Set title id
                    variables:
                      title_id: "itinerary_canceled"
                  - alias: Get notification translation
                    variables: *get_translation
                  - alias: Notify driver of itinerary cancelation
                    action: "{{ notify_service }}"
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                      data: *notification_data
                  - sequence: *tts
                  - alias: Mark error in driver itinerary sensor
                    action: input_text.set_value
                    target:
                      entity_id: "{{ itinerary_sensor }}"
                    data:
                      value: "error: {{ message_id }}"
              - alias: Restore iBeacon states
                sequence: &restore_ibeacons
                  - alias: If driver has an iBeacon entity set for auto-closing
                    if:
                      - condition: template
                        value_template: "{{ (ble_entities | length) - 1 >= idx }}"
                    then:
                      - alias: If driver has a saved iBeacon transmitter state
                        if:
                          - condition: template
                            value_template: "{{ old_ibeacon_transmitter_states != none }}"
                        then:
                          - alias: If iBeacon transmitter was stopped, stop it
                            if:
                              - condition: template
                                value_template: "{{ old_ibeacon_transmitter_states['state'] != none }}"
                            then:
                              - action: "{{ notify_service }}"
                                data:
                                  message: command_ble_transmitter
                                  data:
                                    command: turn_off
                          - alias: If iBeacon transmitting power was not set to high, restore it
                            if:
                              - condition: template
                                value_template: "{{ old_ibeacon_transmitter_states['transmit_power'] != none }}"
                            then:
                              - action: "{{ notify_service }}"
                                data:
                                  message: command_ble_transmitter
                                  data:
                                    command: ble_set_transmit_power
                                    ble_transmit: "ble_transmit_{{ old_ibeacon_transmitter_states['transmit_power'] }}"
                          - alias: If iBeacon transmitter advertise power was not set to low latency, restore it
                            if:
                              - condition: template
                                value_template: "{{ old_ibeacon_transmitter_states['advertise_mode'] != none }}"
                            then:
                              - action: "{{ notify_service }}"
                                data:
                                  message: command_ble_transmitter
                                  data:
                                    command: ble_set_advertise_mode
                                    ble_advertise: "ble_advertise_{{ old_ibeacon_transmitter_states['advertise_mode'] }}"
                  - alias: If iBeacon switch set, and doesn't need to stay on
                    if:
                      - condition: template
                        value_template: "{{ ble_scanner_switch != '' and itinerary_sensors | select('is_state', ['on_approach', 'leaving']) | list == [] }}"
                    then:
                      - alias: Deactivate iBeacon scanner
                        action: switch.turn_off
                        target:
                          entity_id: "{{ ble_scanner_switch }}"
              - stop: Opening canceled
      - alias: Set driver itinerary to "leaving"
        action: input_text.set_value
        target:
          entity_id: "{{ itinerary_sensor }}"
        data:
          value: leaving
      - alias: Set departure variables for the following sequence block
        variables:
          itinerary_mode: "departure"
          opening_behavior: !input departure_opening_behavior
          closing_behavior: !input departure_closing_behavior
          opening_message: "leaving_home"
          took_too_long_message: "did_not_leave"
      - alias: Open and close gate by following behaviors set by the user
        sequence: &open_close_behavior
          - alias: If opening behavior is set to cancelable timer or notification request
            if:
              - condition: template
                value_template: "{{ opening_behavior in ['timer', 'notif'] }}"
            then:
              - choose:
                  - alias: If opening behavior is set to cancelable timer
                    conditions:
                      - condition: template
                        value_template: "{{ opening_behavior == 'timer' }}"
                    sequence:
                      - alias: Set notification ids
                        variables:
                          message_id: "{{ opening_message }}"
                          title_id: "open_gate"
                      - alias: Get notification translation
                        variables: *get_translation
                      - alias: Get button translation
                        variables: &get_button_translations
                          button_ids:
                            - "open"
                            - "cancel"
                          buttons: |-
                            {% set data = namespace(buttons=[]) %}
                            {% for button_id in button_ids %}
                              {# Custom translation #}
                              {%
                                if 'button' in custom_translations_json
                                and button_id in custom_translations_json['button']
                              %}
                                {% set translation = custom_translations_json['button'][button_id] %}

                              {# Selected language #}
                              {% elif button_id in strings[language]['button'] %}
                                {% set translation = strings[language]['button'][button_id] %}

                              {# Fallback to english #}
                              {% else %}
                                {% set translation = strings['en']['button'][button_id] %}
                              {% endif %}

                              {% set data.buttons = data.buttons + [translation] %}

                            {% endfor %}
                            {{ data.buttons }}
                      - alias: Ask the user if he wants to open the gate
                        action: "{{ notify_service }}"
                        data:
                          title: "{{ title }}"
                          message: "{{ message }}"
                          data:
                            notification_icon: mdi:lock-question
                            sticky: true
                            persistent: true
                            timeout: ""
                            actions:
                              - action: "{{ opening_order_id }}"
                                title: "{{ buttons[0] }}"
                              - action: "{{ canceling_order_id }}"
                                title: "{{ buttons[1] }}"
                  - alias: If opening behavior is set to notification request
                    conditions:
                      - condition: template
                        value_template: "{{ opening_behavior == 'notif' }}"
                    sequence:
                      - alias: Set notification ids
                        variables:
                          message_id: "{{ opening_message }}"
                          title_id: "timer_opening"
                      - alias: Get notification translation
                        variables: *get_translation
                      - alias: Get button translation
                        variables:
                          button_ids:
                            - "cancel"
                            - "open"
                          <<: *get_button_translations
                      - alias: Send the cancelable timer notification to the user
                        action: "{{ notify_service }}"
                        data:
                          title: "{{ title }}"
                          message: "{{ message }}"
                          data:
                            notification_icon: mdi:timer-lock-open
                            sticky: true
                            persistent: true
                            timeout: "{{ timer }}"
                            chronometer: true
                            when: "{{ timer }}"
                            when_relative: true
                            actions:
                              - action: "{{ canceling_order_id }}"
                                title: "{{ buttons[0] }}"
                              - action: "{{ opening_order_id }}"
                                title: "{{ buttons[1] }}"
              - sequence: *tts
              - alias: Wait for events before opening the gate or canceling the itinerary
                wait_for_trigger:
                  - alias: Manual opening
                    trigger: template
                    id: manual
                    value_template: "{{ gate | select('is_state', ['on', 'open', 'opening']) | list != [] }}"
                  - alias: Vehicle left
                    trigger: template
                    id: vehicle_stopped
                    value_template: "{{ is_state(driving_sensor, 'off') }}"
                  - alias: Activation zone left
                    trigger: template
                    id: vehicle_away
                    value_template: &activation_zone_out_trigger |-
                      {% if state_attr(person, 'gps_accuracy') is none %}
                        {% set accuracy = 100 %}
                      {% else %}
                        {% set accuracy = state_attr(person, 'gps_accuracy') %}
                      {% endif %}
                      {% set gate_distance = distance(person, gate_location)*1000 - accuracy %}

                      {{ gate_distance > activation_zone }}
                  - alias: Forbidden zone entered
                    trigger: template
                    id: forbidden_zone
                    value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                  - alias: Opening button pressed
                    trigger: event
                    id: opening_order
                    event_type: mobile_app_notification_action
                    event_data:
                      action: "{{ opening_order_id }}"
                  - alias: Canceling button pressed
                    trigger: event
                    id: canceling_order
                    event_type: mobile_app_notification_action
                    event_data:
                      action: "{{ canceling_order_id }}"
                timeout: |-
                  {% if opening_behavior == 'timer' %}
                    {{ timer }}
                  {% else %}
                    2147483647
                  {% endif %}
              - if:
                  - condition: template
                    value_template: |-
                      {{
                        wait.remaining == 0
                        and opening_behavior != 'timer'
                      }}
                then:
                  - stop: This timer shouldn't reach zero !
                    error: true
              - alias: If an error needs to be raised
                if:
                  - condition: template
                    value_template: "{{ wait.trigger.id in ['vehicle_stopped', 'vehicle_away', 'forbidden_zone', 'canceling_order'] }}"
                then:
                  - alias: Set error id
                    variables:
                      message_id: "{{ wait.trigger.id }}"
                  - alias: Create error
                    sequence: *create_error
                  - stop: Opening canceled
              - alias: Remove opening notification
                action: "{{ notify_service }}"
                data: &clear_notification
                  message: clear_notification
                  data:
                    tag: itinerary-status
          - alias: If opening is enabled
            if:
              - condition: template
                value_template: "{{ opening_behavior != 'off' }}"
            then:
              - alias: If one of the gates is closing/closed
                if:
                  - condition: template
                    value_template: "{{ gate | select('is_state', ['off', 'closed', 'closing']) | list != [] }}"
                then:
                  - alias: Open each gate because driver is leaving
                    repeat:
                      for_each: !input gate
                      sequence:
                        - action: |-
                            {% if states[repeat.item].domain == 'switch' %}
                              switch.turn_on
                            {% elif states[repeat.item].domain == 'cover' %}
                              cover.open_cover
                            {% endif %}
                          target:
                            entity_id: "{{ repeat.item }}"
          - alias: Set variables for the following repeat sequence
            variables:
              break: "{{ closing_behavior in ['auto', 'off'] }}"
              suggest_closing: |-
                {{
                  closing_behavior == 'notif'
                  and itinerary_mode == 'departure'
                  and 'ble' not in close_when_disconnected_from
                }}
          - alias: Wait for events at least once, then while the gate closing has not been triggered
            repeat:
              until: "{{ break }}"
              sequence:
                - alias: Wait for events before closing the gate
                  wait_for_trigger:
                    - alias: Manual closing
                      trigger: template
                      id: manual
                      value_template: "{{ gate | select('is_state', ['off', 'closed', 'closing']) | list != [] }}"
                    - alias: iBeacon out of reach
                      trigger: template
                      id: ble_out_of_range
                      value_template: "{{ (ble_entities | length) - 1 >= idx and is_state(ble_entities[idx], 'unknown') }}"
                      enabled: "{{ 'ble' in close_when_disconnected_from }}"
                    - alias: Vehicle left
                      trigger: template
                      id: vehicle_stopped
                      value_template: "{{ is_state(driving_sensor, 'off') }}"
                    - alias: Activation zone left
                      trigger: template
                      id: vehicle_away
                      value_template: *activation_zone_out_trigger
                    - alias: Forbidden zone
                      trigger: template
                      id: forbidden_zone
                      value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                    - alias: Closing button pressed
                      trigger: event
                      id: closing_order
                      event_type: mobile_app_notification_action
                      event_data:
                        action: "{{ closing_order_id }}"
                    - alias: Canceling button pressed
                      trigger: event
                      id: canceling_order
                      event_type: mobile_app_notification_action
                      event_data:
                        action: "{{ canceling_order_id }}"
                  timeout:
                    seconds: |-
                      {% if repeat.first %}
                        {% if closing_behavior == 'timer' %}
                          {{ timer }}
                        {% elif suggest_closing %}
                          {{ suggest_closing_after }}
                        {% else %}
                          {{ safety_delay * 60 }}
                        {% endif %}
                      {% else %}
                        2147483647
                      {% endif %}
                - alias: If the trigger needs to close the gate
                  if:
                    - condition: template
                      value_template: |-
                        {{
                          wait.trigger.id in ['manual', 'closing_order']
                          or wait.remaining == 0 and closing_behavior == 'timer'
                        }}
                  then:
                    - alias: Break the loop next time
                      variables:
                        break: true
                - alias: If this is the first loop
                  if:
                    - condition: template
                      value_template: "{{ repeat.first }}"
                  then:
                    - alias: If the user is leaving
                      if:
                        - condition: template
                          value_template: "{{ itinerary_mode == 'departure' }}"
                      then:
                        - alias: Restore iBeacon states
                          sequence: *restore_ibeacons
                    - alias: Set message id
                      variables:
                        message_id: |-
                          {% if wait.remaining == 0 %}
                            {% if closing_behavior == 'timer' %}
                              {{ none }}
                            {% elif suggest_closing %}
                              closing_suggestion
                            {% else %}
                              {{ took_too_long_message }}
                            {% endif %}
                          {% elif wait.trigger.id in ['manual', 'closing_order'] %}
                            {{ none }}
                          {%
                            elif wait.trigger.id == 'vehicle_stopped'
                            and itinerary_mode == 'arrival'
                          %}
                            arrived
                          {% else %}
                            {{ wait.trigger.id }}
                          {% endif %}
                    - alias: If a closing notification needs to be sent
                      if:
                        - condition: template
                          value_template: "{{ not break }}"
                      then:
                        - choose:
                            - alias: If closing behavior is set to cancelable timer
                              conditions:
                                - condition: template
                                  value_template: "{{ closing_behavior == 'timer' }}"
                              sequence:
                                - alias: Get title id
                                  variables:
                                    title_id: "timer_closing"
                                - alias: Get notification translation
                                  variables: *get_translation
                                - alias: Get button translation
                                  variables:
                                    button_ids:
                                      - "cancel"
                                      - "close"
                                    <<: *get_button_translations
                                - alias: Ask the user if he wants to close the gate
                                  action: "{{ notify_service }}"
                                  data:
                                    title: "{{ title }}"
                                    message: "{{ message }}"
                                    data:
                                      <<: *notification_data
                                      notification_icon: mdi:lock-question
                                      sticky: true
                                      persistent: true
                                      timeout: "{{ timer }}"
                                      chronometer: true
                                      when: "{{ timer }}"
                                      when_relative: true
                                      actions:
                                        - action: "{{ canceling_order_id }}"
                                          title: "{{ buttons[0] }}"
                                        - action: "{{ closing_order_id }}"
                                          title: "{{ buttons[1] }}"
                            - alias: If closing behavior is set to notification request
                              conditions:
                                - condition: template
                                  value_template: "{{ closing_behavior == 'notif' }}"
                              sequence:
                                - alias: Set title id
                                  variables:
                                    title_id: "close_gate"
                                - alias: Get notification translation
                                  variables: *get_translation
                                - alias: Get button translation
                                  variables:
                                    button_ids:
                                      - "close"
                                      - "cancel"
                                    <<: *get_button_translations
                                - alias: Ask the user if he wants to close the gate
                                  action: "{{ notify_service }}"
                                  data:
                                    title: "{{ title }}"
                                    message: "{{ message }}"
                                    data:
                                      <<: *notification_data
                                      notification_icon: mdi:lock-question
                                      sticky: true
                                      persistent: true
                                      timeout: ""
                                      actions:
                                        - action: "{{ closing_order_id }}"
                                          title: "{{ buttons[0] }}"
                                        - action: "{{ canceling_order_id }}"
                                          title: "{{ buttons[1] }}"
                        - sequence: *tts
                  else:
                    - alias: If the itinerary needs to be canceled
                      if:
                        - condition: template
                          value_template: "{{ wait.trigger.id == 'canceling_order' }}"
                      then:
                        - alias: Set error id
                          variables:
                            message_id: "canceling_order"
                        - alias: Create error
                          sequence: *create_error
                        - stop: Closing canceled
          - alias: If itinerary started or departure gate closing notification was sent
            if:
              - condition: template
                value_template: |-
                  {{
                    itinerary_mode == 'arrival'
                    or closing_behavior in ['timer', 'notif']
                  }}
            then:
              - alias: Remove closing notification
                action: "{{ notify_service }}"
                data: *clear_notification
          - alias: Remove current itinerary
            action: input_text.set_value
            target:
              entity_id: "{{ itinerary_sensor }}"
            data:
              value: none
          - alias: If gate not closed manually
            if:
              - condition: template
                value_template: "{{ wait.trigger.id != 'manual' }}"
            then:
              - alias: If closing is enabled
                if:
                  - condition: template
                    value_template: "{{ closing_behavior != 'off' }}"
                then:
                  - alias: If someone is currently approaching or leaving
                    if:
                      - condition: template
                        value_template: "{{ itinerary_sensors | select('is_state', ['on_approach', 'leaving']) | list != [] }}"
                    then:
                      - alias: Get names of awaited persons
                        variables:
                          awaited_persons: |-
                            {% set data = namespace(awaited_persons=[]) %}

                            {% for sensor_idx in range(itinerary_sensors | length) %}
                              {%
                                if sensor_idx != idx
                                and is_state(itinerary_sensors[sensor_idx], ['on_approach', 'leaving'])
                              %}
                                {%
                                  set data.awaited_persons = data.awaited_persons + [
                                    state_attr(persons[sensor_idx], 'friendly_name')
                                  ]
                                %}
                              {% endif %}
                            {% endfor %}

                            {{ data.awaited_persons | join(', ') }}
                      - alias: Set notification ids
                        variables:
                          title_id: "awaiting"
                          message_id: "awaiting"
                      - alias: Get notification translation
                        variables: *get_translation
                      - alias: Notify driver that gate will wait for next person
                        action: "{{ notify_service }}"
                        data:
                          title: "{{ title }}"
                          message: "{{ message }}"
                          data:
                            <<: *notification_data
                            notification_icon: mdi:sleep
                            timeout: ""
                      - sequence: *tts
                      - alias: Wait for gate closed
                        wait_for_trigger:
                          - trigger: template
                            value_template: "{{ gate | select('is_state', ['off', 'closed', 'closing']) | list != [] }}"
                      - alias: Remove awaiting user notification
                        action: "{{ notify_service }}"
                        data: *clear_notification
                    else:
                      - alias: If an error needs to be raised
                        if:
                          - condition: template
                            value_template: |-
                              {{
                                closing_behavior in ['auto', 'off']
                                and message_id is not none
                                and message_id != 'arrived'
                              }}
                        then:
                          - alias: Create error
                            sequence: *create_error
                        else:
                          - alias: Set prefix
                            variables:
                              prefix: "{{ itinerary_mode == 'departure' | iif('', 'un') }}"
                          - alias: Do not lock if dont_lock_if_people_remaining is true and someone else is home
                            if:
                              - condition: template
                                value_template: |-
                                  {{
                                    prefix == 'un'
                                    or not dont_lock_if_people_remaining
                                    or not expand(gate_location)
                                      | map(attribute='entity_id')
                                      | list
                                      | difference([person])
                                  }}
                            then:
                              - alias: Unlock or lock all locks
                                repeat:
                                  for_each: !input locks
                                  sequence:
                                    - action: "lock.{{ prefix }}lock"
                                      target:
                                        entity_id: "{{ repeat.item }}"
                      - alias: Close all gates
                        repeat: &close_gates
                          for_each: !input gate
                          sequence:
                            - action: |-
                                {% if states[repeat.item].domain == 'switch' %}
                                  switch.turn_off
                                {% elif states[repeat.item].domain == 'cover' %}
                                  cover.close_cover
                                {% endif %}
                              target:
                                entity_id: "{{ repeat.item }}"
      - alias: Wait for driver to travel 250m away from activation zone, then return, to start itinerary
        repeat:
          count: 2
          sequence:
            - wait_for_trigger:
                - trigger: template
                  id: vehicle_stopped
                  value_template: "{{ is_state(driving_sensor, 'off') }}"
                - trigger: template
                  value_template: |-
                    {% if state_attr(person, 'gps_accuracy') is none %}
                      {% set accuracy = 100 %}
                    {% else %}
                      {% set accuracy = state_attr(person, 'gps_accuracy') %}
                    {% endif %}
                    {% set gate_distance = distance(person, gate_location)*1000 - accuracy %}

                    {{ gate_distance > activation_zone + 250 }}
                - trigger: template
                  value_template: |-
                    {% if state_attr(person, 'gps_accuracy') is none %}
                      {% set accuracy = 100 %}
                    {% else %}
                      {% set accuracy = state_attr(person, 'gps_accuracy') %}
                    {% endif %}
                    {% set gate_distance = distance(person, gate_location)*1000 + accuracy %}

                    {{ gate_distance < activation_zone }}
            - alias: Don't continue if driver stopped vehicle
              if:
                - condition: template
                  value_template: "{{ wait.trigger.id == 'vehicle_stopped' }}"
              then:
                - stop: Arrived to destination

    else:
      - alias: Stop if driver started driving in activation zone
        if:
          - condition: template
            value_template: *activation_zone_in_condition
        then:
          - alias: Set error id
            variables:
              message_id: "too_close"
          - alias: Create error
            sequence: *create_error
          - stop: Started too close to home

  ###################
  # START ITINERARY #
  ###################

  - alias: Set driver itinerary to "arriving"
    action: input_text.set_value
    target:
      entity_id: "{{ itinerary_sensor }}"
    data:
      value: arriving
  - alias: Set notification ids
    variables:
      title_id: "itinerary_started"
      message_id: "vehicle_started"
  - alias: Get notification translation
    variables: *get_translation
  - alias: Notify driver of itinerary start
    action: "{{ notify_service }}"
    data:
      title: "{{ title }}"
      message: "{{ message }}"
      data:
        <<: *notification_data
        notification_icon: mdi:map-check
        timeout: ""
  - sequence: *tts
  - alias: Repeat while driver still driving
    repeat:
      while:
        - condition: template
          value_template: "{{ is_state(driving_sensor, 'on') }}"
      sequence:
        - alias: Reset opening time variable
          variables:
            opening_time: "{{ none }}"
        - alias: Update travel time if expired and refresh rate set to "Continuously"
          if:
            - condition: template
              value_template:  "{{ travel_time_rate == 'continuous' and
                states[travel_time_sensor].last_updated + timedelta(minutes=continuously_refresh_interval) < now() }}"
          then:
            - alias: Set variables for the following sequence
              variables:
                quick_update_trigger: "{{ continuously_refresh_interval * 60 - 30 }}"
                reset_after: "{{ continuously_refresh_interval * 120 }}"
            - sequence: &update_travel_time
                - alias: Stop if travel time sensor does not exist
                  if:
                    - condition: template
                      value_template: "{{ states[travel_time_sensor] is none }}"
                  then:
                    - alias: Set error id
                      variables:
                        message_id: "invalid_travel_time_sensor"
                    - alias: Create error
                      sequence: *create_error
                    - alias: Log error
                      action: system_log.write
                      data:
                        level: error
                        message: "{{ message }}"
                        logger: blueprints.etiennec78.automatic_gate
                    - stop: Travel time sensor does not exist
                      error: true
                - alias: Only update the travel time if it has not already been updated recently
                  if:
                    - condition: template
                      value_template: "{{ now() - states[travel_time_sensor].last_updated > timedelta(seconds=quick_update_trigger) }}"
                  then:
                    - alias: Update travel time
                      action: homeassistant.update_entity
                      target:
                        entity_id: "{{ travel_time_sensor }}"
                  else:
                    - alias: If the last quick update was a long time ago
                      if:
                        - condition: template
                          value_template: |-
                            {{
                              last_quick_tt_update is not none
                              and last_quick_tt_update + timedelta(seconds=reset_after) > now()
                            }}
                      then:
                        - alias: Note that the travel time sensor tried to update too quickly
                          variables:
                            quick_tt_updates: "{{ quick_tt_updates + 1 }}"
                      else:
                        - alias: Reset the quick travel time updates counter
                          variables:
                            quick_tt_updates: 1
                    - alias: Reset the last quick update variable
                      variables:
                        last_quick_tt_update: "{{ now() }}"
                    - alias: If 20 travel time updates were too quick
                      if:
                        - condition: template
                          value_template: "{{ quick_tt_updates > 20 }}"
                      then:
                        - alias: Mark error in driver itinerary sensor
                          action: input_text.set_value
                          target:
                            entity_id: "{{ itinerary_sensor }}"
                          data:
                            value: "error: updated_frequently"
                        - alias: Set error id
                          variables:
                            message_id: "disabled_updated_frequently"
                        - alias: Get notification translation
                          variables: *get_translation
                        - alias: Disable the blueprint
                          sequence: *disable_blueprint
                        - alias: Log error
                          action: system_log.write
                          data:
                            level: error
                            message: "{{ message }}"
                            logger: blueprints.etiennec78.automatic_gate
                        - stop: Travel time refreshing too quickly
                          error: true
        - alias: Wait for new driver position or vehicle left
          wait_for_trigger:
            - trigger: event
              event_type: state_changed
              event_data:
                entity_id: "{{ person }}"
            - trigger: template
              value_template: "{{ is_state(driving_sensor, 'off') }}"
        - alias: Stop if the user is in a forbidden zone
          if:
            - condition: template
              value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
          then:
            - sequence: &forbidden_zone
                - alias: Set error id
                  variables:
                    message_id: "forbidden_zone"
                - alias: Create error
                  sequence: *create_error
                - stop: Forbidden zone
        - alias: Repeat while driver in activation zone and still driving
          # This allows to update to a precise ETA even if a traffic jam appears near your gate
          # It will return to the previous loop if the driver has entered the radius but passed by
          repeat:
            while:
              - alias: Still in the activation zone
                condition: template
                value_template: *activation_zone_in_condition
              - alias: Still driving
                condition: template
                value_template: "{{ is_state(driving_sensor, 'on') }}"
            sequence:
              - alias: Set variables for the following sequence
                variables:
                  quick_update_trigger: 1
                  reset_after: 20
              - alias: If the travel time needs to be updated
                if:
                  - condition: template
                    value_template: |-
                      {{
                        travel_time_rate in ['continuous', 'near-home']
                        or opening_time is none
                          and travel_time_rate == 'once'
                          and failed_updates < 20
                      }}
                then:
                  - alias: Update travel time
                    sequence: *update_travel_time
              - alias: If the travel time sensor is not unknown or unavailable
                if:
                  - condition: template
                    value_template: "{{ states(travel_time_sensor) not in ['unknown', 'unavailable'] }}"
                then:
                  - alias: Convert travel time to seconds
                    variables:
                      travel_time_duration: |-
                        {% if (state_attr(travel_time_sensor, 'duration') != none) %}
                          {{ state_attr(travel_time_sensor, 'duration') | float * 60 }}
                        {% elif (state_attr(travel_time_sensor, 'unit_of_measurement') == "min") %}
                          {{ states(travel_time_sensor) | float * 60 }}
                        {% elif (state_attr(travel_time_sensor, 'unit_of_measurement') == "s") %}
                          {{ states(travel_time_sensor) | float }}
                        {% else %}
                          unknown
                        {% endif %}
                  - alias: Stop if travel time integration is not supported
                    if:
                      - condition: template
                        value_template: "{{ travel_time_duration == 'unknown' }}"
                    then:
                      - alias: Set error id
                        variables:
                          message_id: "unsupported_tt_integration"
                      - alias: Create error
                        sequence: *create_error
                      - alias: Log error
                        action: system_log.write
                        data:
                          level: error
                          message: "{{ message }}"
                          logger: blueprints.etiennec78.automatic_gate
                      - stop: Travel time integration not supported
                        error: true
                  - alias: Set the opening time
                    variables:
                      opening_time: |-
                        {{
                          states[travel_time_sensor].last_updated | as_timestamp
                            + travel_time_duration
                            - lead_time
                            - (timer if opening_behavior == 'timer' else 0)
                        }}
                else:
                  - alias: Add 1 to the failed updates counter
                    variables:
                      failed_updates: "{{ failed_updates + 1 }}"
              - alias: Set a timer for the gate opening (or max int value if travel time sensor is unknown and no previous eta was stored)
                variables:
                  seconds_before_opening: |-
                    {% if opening_time is none %}
                      2147483647
                    {% else %}
                      {{ opening_time - now() | as_timestamp }}
                    {% endif %}
              - alias: If ETA in the future or no opening time could be set
                if:
                  - condition: template
                    value_template: "{{ seconds_before_opening > 1 }}"
                then:
                  - alias: Wait for ETA, travel time, new position, vehicle left, and cancel if deviced timed out
                    wait_for_trigger:
                      - trigger: event
                        event_type: state_changed
                        event_data:
                          entity_id: "{{ person }}"
                      - trigger: event
                        event_type: state_changed
                        event_data:
                          entity_id: "{{ travel_time_sensor }}"
                        enabled: "{{ travel_time_rate == 'listen' }}"
                      - trigger: template
                        value_template: "{{ is_state(driving_sensor, 'off') }}"
                    timeout:
                      seconds: |-
                        {% if travel_time_rate == 'once' %}
                          {{ seconds_before_opening }}
                        {% else %}
                          {{ min(timeout_delay*60, seconds_before_opening) }}
                        {% endif %}
                  - choose:
                      - alias: If timeout ran out of time (not because of eta reached)
                        conditions:
                          - condition: template
                            value_template: |-
                              {{
                                wait.remaining == 0
                                and opening_time is not none
                                and opening_time > now() | as_timestamp
                              }}
                        sequence:
                          - alias: Set error id
                            variables:
                              message_id: "timed_out"
                          - alias: Create error
                            sequence: *create_error
                          - stop: Timed out
                      - alias: Stop if the user is in a forbidden zone
                        conditions:
                          - condition: template
                            value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                        sequence: *forbidden_zone
              - alias: Return to the previous loop if the travel time sensor is unknown and no previous eta was stored
                condition: template
                value_template: "{{ opening_time is not none }}"
              - alias: Return to the previous loop if the wait_for_trigger was triggered by a position or vehicle sensor update
                condition: template
                value_template: "{{ opening_time <= as_timestamp(now()) }}"
              - alias: Return to the previous loop if the user has left the the activation zone
                condition: template
                value_template: *activation_zone_in_condition
              - alias: Set driver itinerary text variable to "on_approach", because driver is near gate and will arrive soon
                action: input_text.set_value
                data:
                  value: on_approach
                target:
                  entity_id: "{{ itinerary_sensor }}"
              - alias: Set arrival variables for the following sequence block
                variables:
                  itinerary_mode: "arrival"
                  opening_behavior: !input arrival_opening_behavior
                  closing_behavior: !input arrival_closing_behavior
                  opening_message: "soon_arrived"
                  took_too_long_message: "did_not_arrive"
              - alias: Open and close gate by following behaviors set by the user
                sequence: *open_close_behavior
              - alias: Stop whole script as successful
                stop: Successful
  - alias: If vehicle left in gate zone and travel time was not updated
    if:
      condition: template
      value_template: |-
        {{
          is_state(person, [state_attr(gate_location, 'friendly_name'), states[gate_location].object_id])
          and opening_time is none
        }}
    then:
      - alias: Set error id
        variables:
          message_id: "travel_time_did_not_respond"
      - alias: Create error
        sequence: *create_error
      - alias: Log error
        action: system_log.write
        data:
          level: error
          message: "{{ message }}"
          logger: blueprints.etiennec78.automatic_gate
      - stop: Travel time did not respond
        error: true
    else:
      - alias: Set error id
        variables:
          message_id: "vehicle_stopped"
      - alias: Create error
        sequence: *create_error
# Run in parralel to let the automation start with multiple users driving simultaneously
mode: parallel
max: 10
