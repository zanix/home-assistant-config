blueprint:
  name: Automatic Gate ‚õ©Ô∏è
  source_url: "https://github.com/etiennec78/Home-Automation/blob/master/Blueprints/Automatic-Gate/automatic-gate.yaml"
  domain: automation
  author: etiennec78
  description: |-
    # Automatic Gate ‚õ©Ô∏è

    ## Description üìù
    Modular and secure gate automation that opens and closes your gate upon leaving or arriving
    Makes managing your gate while driving easier: You won't ever have to use your remote again

    ## Key Features üåü
    * **Multi-User Support**: Manages up to 10 drivers simultaneously üöó
    * **Broad Compatibility**: This blueprint is compatible with most vehicles and most travel time providers (Waze, Here, smart vehicles) üîó
    * **Notification Translations**: This blueprint ships with built-in and custom translations üåç
    * **Security & Reliability**:
      * Precise ETA calculations to have your gate fully open exactly when you arrive home üéØ
      * Vehicle status monitoring to cancel the itinerary and close the gate if you stop your vehicle or pass by without entering ‚úã
      * Collision prevention to ensure the gate doesn't close on anyone arriving or leaving at the same time üöß
      * Built-in timeouts in case of an internet loss ‚è≥
      * Maximum entry and leaving time before auto-closing ‚åõ
      * Custom forbidden zones to cancel the itinerary when entered ‚õî
      * Notification alerts at each decision of the automation üö®
    * **Customizable Settings**:
      * Open/Close the gate
        * Automatically üß†
        * By asking for a confirmation ‚úÖ
        * By starting a cancellable timer ‚è±Ô∏è
      * Customizable gate operation timings üõ†Ô∏è
      * Customizable travel time refresh rate üîÅ
      * Read notifications aloud on Android üó£Ô∏è
      * Multiple gate support ‚õ©Ô∏è
      * Open/Close with BLE trackers üì°
      * House locks support üîê
      * Avoid opening when parked near house üÖøÔ∏è

    ## More info ‚ÑπÔ∏è
    * Version: 2.0.0 (878094c)
    * Set up sensors: [click here](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md)
    * Github: [click here](https://github.com/etiennec78/Home-Automation/tree/master/Blueprints/Automatic-Gate)
    * Discord: @etiennec78
    [![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/C0C5XVRMM)
  homeassistant:
    min_version: 2025.4.0
  input:
    essential_inputs:
      name: Essential inputs
      icon: "mdi:gate"
      collapsed: true
      input:
        gate:
          name: ‚õ©Ô∏è Gate
          description: The **switch** or **cover** which controls your **[gate](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#gate-%EF%B8%8F)**
          selector:
            entity:
              multiple: true
              filter:
                domain:
                  - switch
                  - cover
        gate_location:
          name: üìç Gate location
          description: The zone where your gate is located, to detect whether you are leaving or arriving
          default: "zone.home"
          selector:
            entity:
              filter:
                domain: zone
        lead_time:
          name: üïì Lead time
          description: The **lead time** to open the gate **before your arrival** (take your gate movement time & a margin into account)
          default: 75
          selector:
            number:
              min: 10
              max: 300
              unit_of_measurement: seconds

    per_person_sensors:
      name: Per person sensors
      icon: mdi:account-multiple
      collapsed: true
      description: |-
        ‚ö†Ô∏è Please enter the same number of entries in each input (unless otherwise specified) and place users in the same order
      input:
        persons:
          name: üë§ Persons / GPS trackers
          description: |-
            Each **user** which should be **[tracked](https://github.com/etiennec78/Home-Automation/blob/master/sensors.gps-location-trackers--persons-)** for **position updates**
            *Notes :*
            *‚ö†Ô∏è Use high precision while driving in your ETA zone or you could time out*
            *If your tracker has report latency (wifi/ble), and you plug Android Auto just after leaving, your gate could open thinking you are still there*
            *You can only enter one device tracker for multiple users if it is provided by your vehicle*
          selector:
            entity:
              multiple: true
              filter:
                domain:
                  - device_tracker
                  - person
        driving_sensors:
          name: üöó Driving sensors
          description: Each **[driving sensor](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#driving-sensors-)** which should trigger the automation
          selector:
            entity:
              multiple: true
              filter:
                domain:
                  - binary_sensor
                  - input_boolean
        travel_time_sensors:
          name: ‚úàÔ∏è Travel time sensors
          description: |-
            Each **[travel time sensor](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#travel-time-sensors-%EF%B8%8F)** per person/trackers, monitoring their **time left before arrival**
            *‚ö†Ô∏è Please set a [custom polling interval](https://www.home-assistant.io/integrations/waze_travel_time/#defining-a-custom-polling-interval) if using an external service (Waze, Maps, Here, ...)*
            *Note: Optional if open when connected to BLE is true*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: sensor
                device_class:
                  - duration
                  - timestamp
        notify_devices:
          name: üí¨ Notify devices
          description: |-
            Each [**device** to **notify**](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#notify-services-)
            *Notes:*
            *Optional but highly recommended*
            *If the driver does not have a notify devices, gate behaviors will be limited to fully auto or disabled*
          default: []
          selector:
            device:
              multiple: true
              filter:
                integration: mobile_app
        itinerary_sensors:
          name: üó∫Ô∏è Itinerary sensors
          description: |-
            Each empty **[itinerary input text](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#itinerary-sensors-%EF%B8%8F)** helper to store each user **itinerary state**
            *Note: You can use these sensors to sync multiple instances of the Automatic Gate with different configurations by adding sensors from the others at the end of this list*
          selector:
            entity:
              multiple: true
              filter:
                domain: input_text

    travel_time_settings:
      name: Travel time settings
      icon: mdi:timer
      collapsed: true
      input:
        activation_zone:
          name: üîí Gate activation zone
          description: |-
            At which **distance** from the gate should the automation start estimating when to **open your gate** ?
            Note: It will automatically **close** if you **leave** this zone
          default: 500
          selector:
            number:
              min: 300
              max: 5000
              unit_of_measurement: meters
        travel_time_rate:
          name: üîÑ Travel time refresh rate
          description: |-
            Calculate the Travel time & ETA

              - **Continuously** during the whole itinerary (custom refresh interval while away)
              - Only while the vehicle is **near home**
              - Only **once** when the vehicle gets near home
              - Listen to **external** sensor updates

            **"Continuously"** can use more Waze/Maps credits, but can be useful to display a precise ETA on your dashboard when far from your destination
            **"While near home"** allows to monitor if you drive near your gate without entering to abort the itinerary, or if there are traffic jams near home to open later (recommended)
            **"Only once"** uses the less amount of credits, but could trigger if you come near your gate without entering (not recommended)
            **"Listen for updates"** is made for vehicles providing their own travel time sensor. Do not use with an external travel time provider (e.g: Waze, Maps, Here)
          default: "near-home"
          selector:
            select:
              options:
                - label: Continuously
                  value: "continuous"
                - label: While near home
                  value: "near-home"
                - label: Once when near home
                  value: "once"
                - label: Listen for updates
                  value: "listen"
        continuously_refresh_interval:
          name: ‚è≥ Continuously refresh interval
          description: Your travel time **refresh interval** while away. Only active with a refresh rate set to **"Continuously"**
          default: 5
          selector:
            number:
              min: 1
              max: 60
              unit_of_measurement: minutes

    gate_behavior:
      name: Gate behavior
      icon: mdi:brain
      collapsed: true
      input:
        departure_opening_behavior:
          name: üõ´üîì Departure opening behavior
          description: |-
            Automatic gate **opening** behavior on **departure**

              - **Fully automatic** : Your gate will automatically open
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to open your gate
              - **Disabled** : Your gate will stay closed
          default: "auto"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        departure_closing_behavior:
          name: üõ´üîê Departure closing behavior
          description: |-
            Automatic gate **closing** behavior on **arrival**

              - **Fully automatic** : Your gate will automatically close
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to close your gate
              - **Disabled** : Your gate won't close automatically
          default: "notif"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        suggest_closing_after:
          name: üîê Suggest closing after
          description: The time the gate will wait before **suggesting to close** on departure if you are using a **notification request** but don't have a sensor to detect your absence
          default: 120
          selector:
            number:
              min: 1
              max: 600
              unit_of_measurement: seconds
        arrival_opening_behavior:
          name: üõ¨üîì Arrival opening behavior
          description: |-
            Gate automatic **opening** behavior on **arrival**

              - **Fully automatic** : Your gate will automatically open
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to open your gate
              - **Disabled** : Your gate will stay closed
          default: "auto"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        arrival_closing_behavior:
          name: üõ¨üîê Arrival closing behavior
          description: |-
            Gate automatic **closing** behavior on **arrival**

              - **Fully automatic** : Your gate will automatically close
              - **Cancelable timer** : A notification of a cancelable timer will be sent before opening your gate
              - **Notification request** : An actionable notification will be sent to close your gate
              - **Disabled** : Your gate won't close automatically
          default: "auto"
          selector:
            select:
              options:
                - label: Fully automatic
                  value: "auto"
                - label: Cancelable timer
                  value: "timer"
                - label: Notification request
                  value: "notif"
                - label: Disabled
                  value: "off"
        timer_opening:
          name: ‚è±Ô∏èüîì Cancelable timer time for opening
          description: The time before the gate automatically opens in "cancelable timer" mode without your input
          default: 5
          selector:
            number:
              min: 1
              max: 20
              unit_of_measurement: seconds
        timer_closing:
          name: ‚è±Ô∏èüîê Cancelable timer time for closing
          description: The time before the gate automatically closes in "cancelable timer" mode without your input
          default: 15
          selector:
            number:
              min: 1
              max: 120
              unit_of_measurement: seconds

    security_features:
      name: Security features
      icon: mdi:security
      collapsed: true
      input:
        security_notif_override:
          name: üîÅ Override notification request for safety feature
          description: Change the closing behavior from "notification request" to "timer" if triggered by a safety feature
          default: true
          selector:
            boolean:
        safety_delay:
          name: üîê Auto-close safety delay
          description: The time the gate will wait before **automatically closing** if your gate is open but you still haven't left or arrived
          default: 5
          selector:
            number:
              min: 2
              max: 30
              unit_of_measurement: minutes
        timeout_delay:
          name: ‚åõ Timeout delay
          description: |-
            The time the automation will wait before **stopping** if your phone **times out** and doesn't send new position updates, while being in the activation zone
            *Note : If your position provider doesn't let you use a high accuracy mode (like iOS), please increase this value*
          default: 2
          selector:
            number:
              min: 0.5
              max: 30
              unit_of_measurement: minutes
        forbidden_zones:
          name: ‚õî Forbidden zones
          description: If you enter any of these zones while driving home, your itinerary will be canceled
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: zone
        quick_triggers_reopen_gate:
          name: üö® Reopen gate if driving sensor triggers too quickly
          description: Reopen the gate if your driving sensor keeps turning on and off quickly, to avoid closing on your vehicle
          default: true
          selector:
            boolean:
        ask_reopen_manually_closed:
          name: üöß Ask before reopening if manually closed
          description: If the gate was recently closed, but not automatically, ask the user to confirm before reopening it on departure
          default: true
          selector:
            boolean:

    notification_settings:
      name: Notification settings
      icon: mdi:bell
      collapsed: true
      input:
        language:
          name: Notification language
          description: The **language** in which **notifications** will be sent to you
          default: "en"
          selector:
            language:
              languages:
                - en
                - fr
        custom_translations:
          name: Custom translations
          description: |-
            A **yaml** dictionary to change the default **notifications translations**
            *Note : You can find the translation keys in the strings['en'] variable in the code or in your traces*
          default:
            title: {}
            message: {}
            button: {}
          selector:
            object:
        itinerary_started_notif:
          name: üèÅ Itinerary started notification
          description: Whether or not to send a notification informing the user that his itinerary has been started
          default: true
          selector:
            boolean:
        phone_tts:
          name: üì≥ Phone TTS
          description: Read notifications **aloud** on **Android** phones
          default: false
          selector:
            boolean:
        phone_tts_stream:
          name: üìª Phone TTS audio stream
          description: The **audio stream** used for playing the phone TTS. Can be useful to **bypass Do Not Disturb**.
          default: "notification_stream"
          selector:
            select:
              options:
                - label: Notification stream
                  value: "notification_stream"
                - label: Alarm stream
                  value: "alarm_stream"
                - label: Alarm stream (max volume)
                  value: "alarm_stream_max"

    presence_sensors:
      name: Presence sensors
      icon: mdi:leak
      collapsed: true
      input:
        wifi_devices:
          name: üè† WiFi devices
          description: |-
            Each driver's WiFi device tracker
            *Note : Please place user sensors in the same order*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                - domain: sensor
                  device_class:
                    - signal_strength
                    - distance
                - domain: device_tracker
        ble_entities:
          name: üîé BLE tracker entities
          description: |-
            Each **[BLE tracker entity](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#bluetooth-entities-)** to monitor your distance from the gate
            *Note : Please place user sensors in the same order*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                - domain: sensor
                  device_class:
                    - signal_strength
                    - distance
                    - bermuda__custom_device_class
                - domain: device_tracker
        ble_away_timeout:
          name: ‚åõ BLE away timeout
          description: |-
            Timeout period without receiving updates after which the BLE device will be considered away
            *Note : Some trackers have a built-in away timeout. In this case, this value can be set to 0.*
          default: 0
          selector:
            number:
              min: 0
              max: 300
              unit_of_measurement: seconds
        ble_transmitter_entities:
          name: üì° iBeacon transmitter entities
          description: |-
            Each **[iBeacon transmitter entity](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#bluetooth-transmitter-)** to restore previous iBeacon transmitter power settings when iBeacon is not needed anymore
            *Notes : Let empty if you use iOS, or only use iBeacon for this automation*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                integration: mobile_app
                domain: sensor
                device_class: enum
        ble_scanner_switch:
          name: ‚èØÔ∏è BLE scanner activator switch
          description: |-
            The **[switch](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#bluetooth-scanner-switch-)** to automatically **start and stop BLE scanning** when needed
            *Note : Leave empty if you want your BLE scanner to be always on*
          default: ""
          selector:
            entity:
              filter:
                domain: switch
        only_open_near:
          name: üß≠ Confirm the location on startup
          description: |-
            Wait for a sensor to confirm your location before starting this blueprint
            Useful in case your vehicle is parked near your house, and you don't want your gate to open, or if your phone is too slow to update its gps and could report you home even though you already left
            *Notes :*
            *‚ö†Ô∏è GPS needs the "[Single accurate location](https://github.com/etiennec78/Home-Automation/blob/master/sensors.md#extra-requesting-manual-gps-updates-)" sensor turned on in the companion app*
            *WiFi can be slow to report new states*
          default: []
          selector:
            select:
              multiple: true
              options:
                - label: GPS
                  value: gps
                - label: Wi-Fi (departure)
                  value: wifi
                - label: Bluetooth LE (departure)
                  value: ble
        only_open_near_timeout:
          name: ‚åõ Location confirmation timeout
          description: The time the blueprint will wait for a sensor to confirm your location before canceling the sequence
          default: 60
          selector:
            number:
              min: 0
              max: 1800
              unit_of_measurement: seconds
        gps_outdated_delay:
          name: ‚åõ GPS outdated delay
          description: The timeframe after which the GPS will be considered outdated and a request will be made to update it
          default: 10
          selector:
            number:
              min: 0
              max: 300
              unit_of_measurement: seconds
        close_when_disconnected_from:
          name: üì° Close on departure when disconnected from
          description: Close the gate if driver's BLE device is out of range
          default: []
          selector:
            select:
              multiple: true
              options:
                - label: Bluetooth LE
                  value: ble
        open_when_connected_to:
          name: üì° Open on arrival when connected to
          description: |-
            Open the gate when driver's BLE is reachable
            Enabling this will remove the need of a travel time sensor
          default: []
          selector:
            select:
              multiple: true
              options:
                - label: Bluetooth LE
                  value: ble

    locks:
      name: Door locks
      icon: mdi:door-closed-lock
      collapsed: true
      input:
        locks:
          name: üîê Locks
          description: |-
            The **locks** that open your home's **doors**
            *Note : They will lock on exit once the gate is closed, and unlock once the vehicle has arrived and been turned off*
          default: []
          selector:
            entity:
              multiple: true
              filter:
                domain: lock
        unlatch_doors:
          name: üö™ Unlatch doors
          description: |-
            Open all doors with locks that support unlatching
          default: false
          selector:
            boolean:
        dont_lock_if_people_remaining:
          name: üè† Do not lock if there are still people home
          description: |-
            Avoid locking locks if some person entities are still in the gate zone besides yourself
            Note : if you drive away with multiple people, they might still be detected home and prevent locking
          default: false
          selector:
            boolean:

    config_checker:
      name: Config checker
      icon: mdi:shield-check
      collapsed: true
      input:
        run_checks_when_enabled:
          name: üß™ Run tests when blueprint enabled
          description: Run tests after adding the blueprint, updating inputs, and after HA startup
          default: true
          selector:
            boolean:
        always_run_checks:
          name: üß™ Run tests when triggered
          description: Run tests when the blueprint is triggered by a driving sensor
          default: true
          selector:
            boolean:

variables:
  gate: !input gate
  gate_location: !input gate_location
  gate_areas: "{{ gate | map('area_id') | difference([none]) | list }}"
  lead_time: !input lead_time
  security_notif_override: !input security_notif_override
  safety_delay: !input safety_delay
  timeout_delay: !input timeout_delay
  persons: !input persons
  driving_sensors: !input driving_sensors
  travel_time_sensors: !input travel_time_sensors
  notify_devices: !input notify_devices
  notify_services: "{{ notify_devices | map('device_attr', 'name') | map('slugify') | map('regex_replace', '^', 'notify.mobile_app_') | list }}"
  notify_service: "{{ none }}"
  itinerary_sensors: !input itinerary_sensors
  travel_time_rate: !input travel_time_rate
  continuously_refresh_interval: !input continuously_refresh_interval
  behavior:
    departure:
      opening: !input departure_opening_behavior
      closing: !input departure_closing_behavior
    arrival:
      opening: !input arrival_opening_behavior
      closing: !input arrival_closing_behavior
  activation_zone: !input activation_zone
  suggest_closing_after: !input suggest_closing_after
  timer_opening: !input timer_opening
  timer_closing: !input timer_closing
  language: !input language
  custom_translations: !input custom_translations
  ble_entities: !input ble_entities
  ble_scanner_switch: !input ble_scanner_switch
  ble_transmitter_entities: !input ble_transmitter_entities
  only_open_near: !input only_open_near
  only_open_near_timeout: !input only_open_near_timeout
  gps_outdated_delay: !input gps_outdated_delay
  close_when_disconnected_from: !input close_when_disconnected_from
  itinerary_started_notif: !input itinerary_started_notif
  wifi_devices: !input wifi_devices
  forbidden_zones: !input forbidden_zones
  open_when_connected_to: !input open_when_connected_to
  dont_lock_if_people_remaining: !input dont_lock_if_people_remaining
  quick_tt_updates: 0
  last_quick_tt_update: "{{ none }}"
  failed_updates: 0
  silent_error: false
  config_checker_tag: "{{ 'config-checker-' ~ this.attributes.id }}"
  opening_order_id: "{{ 'opening_order_' ~ this.context.id }}"
  closing_order_id: "{{ 'closing_order_' ~ this.context.id }}"
  canceling_order_id: "{{ 'canceling_order_' ~ this.context.id }}"
  default_itinerary_sensor_value:
    status: "{{ none }}"
    error: "{{ none }}"
    quick_triggers: 0
    last_closed: 0
    auto_closed: false
  timeouts:
    closing_suggestion: !input suggest_closing_after
    safety_delay: "{{ safety_delay * 60 }}"
    timer: !input timer_closing
    default: 2147483647
  timeout_messages:
    closing_suggestion: "closing_suggestion"
    safety_delay: "undefined"
    timer: "{{ none }}"
    default: "{{ none }}"
  blueprint_name: "{{ state_attr(this.entity_id, 'friendly_name') }}"
  strings:
    en:
      title:
        itinerary_started: "Itinerary started üèÅ"
        open_gate: "Open gate ? üîì"
        close_gate: "Close gate ? üîê"
        timer_opening: "Gate opening in {{timer_opening}}s üîì"
        timer_closing: "Gate closing in {{timer_closing}}s üîê"
        gate_reopening: "Gate reopening üîì"
        itinerary_canceled: "Itinerary canceled ‚ùå"
        awaiting: "Gate awaiting {awaited_persons} üí§"
        disabled: "Automatic Gate disabled üö´"
        valid_config: "{{blueprint_name}}: Valid configuration üõ†Ô∏è‚úÖ"
        invalid_config: "{{blueprint_name}}: Invalid configuration üõ†Ô∏è‚ùå"
      message:
        leaving_home: "You are leaving home"
        vehicle_started: "You have started your vehicle"
        soon_arrived: "You will arrive soon"
        arrived: "You have arrived"
        closing_suggestion: "{{suggest_closing_after}} seconds have passed"
        ble_out_of_range: "Your BLE device is out of range"
        awaiting: "The gate will close once all users have entered/exited"
        something_went_wrong: "Something went wrong ! The blueprint stopped unexpectedly."
        vehicle_stopped: "You have left your vehicle"
        canceling_order: "You have pressed the cancel button"
        did_not_leave: "The vehicle did not leave in less than {{safety_delay}} minutes"
        did_not_arrive: "The vehicle did not arrive in less than {{safety_delay}} minutes"
        timed_out: "Your position has not been updated in {{timeout_delay}} minutes"
        vehicle_away: "The vehicle is not in the activation zone"
        travel_time_did_not_respond: "Your travel time integration did not respond during your itinerary"
        not_home: "You were not detected at home"
        location_not_confirmed: "Your location could not be confirmed"
        got_no_gps_data: "Your phone is reachable, but is not sending back its location ! Check that the 'Single Accurate Location' sensor is enabled."
        gate_closed: "The gate has been closed manually"
        triggered_frequently: "The blueprint is being triggered repeatedly !"
        disabled_triggered_frequently: |-
          The blueprint has been triggered {quick_triggers} times in a row
          Please enable the blueprint manually once the issue has been fixed
        disabled_updated_frequently: |-
          The automation spammed the travel time API with requests too quickly
          Please report this issue on GitHub !
        forbidden_zone: "You entered a forbidden zone"
        invalid_travel_time_sensor: "Your travel time sensor does not exist !"
        unsupported_tt_integration: "Your travel time integration is not supported !"
        too_close: "You have started driving too close to the gate zone"
        valid_config: "Your configuration seems valid"
        more_info: "More info"
        invalid_translations: "Your custom translations are not valid. Check the following keys: '{data}'. (#1)"
        missing_ble_entities: "You have not entered any BLE scanners (#2)"
        ble_not_used: "You have entered these BLE scanners: '{data}' but are not using them (#3)"
        missing_wifi_trackers: "You have not entered any Wi-Fi trackers (#4)"
        wifi_not_used: "You have entered these Wi-Fi trackers: '{data}' but are not using them (#5)"
        missing_gps_data: "These trackers/persons: '{data}' do not support GPS tracking (#6)"
        ble_not_unknown: "These BLE trackers: '{data}' are currently not reporting an 'unknown' state. If you are currently near them, you can ignore this error. (#7)"
        missing_arrival_opening_method: "You do not have any way to detect your arrival. Please add a travel time sensor or use a BLE tracker. (#8)"
        too_many_arrival_opening_method: "You are using several methods to detect your arrival. One is enough. (#9)"
        invalid_itinerary_sensor_length: "These itinerary sensors: '{data}' have a maximum length of less than 255 (#10)"
        invalid_per_person_sensors: "You have not entered a consistent number of sensors in the per person sensor inputs (#11)"
        per_person_sensors_mismatch: "These persons: '{data}' appear to have mixed up per person sensors (#12)"
        no_gate_area: "You are using area BLE trackers: '{data}', but your gate has not been placed in an area (#13)"
        wifi_tracker_is_gps: "These trackers: '{data}' are GPS-based, not router-based (#14)"
        invalid_ibeacon_transmitter: "These iBeacon transmitters: '{data}' are invalid (#19)"
        no_compatible_gps_tracker: "These persons cannot be tracked by GPS: '{data}' because they do not have GPS trackers, or they come from a different mobile app than the notification device (#20)"
        deprecated_translations: "Custom translations now use a yaml dictionnary instead of json. Please update your old config. (#21)"
      button:
        open: "Open üîì"
        close: "Close üîê"
        cancel: "Cancel ‚ùå"
    fr:
      title:
        itinerary_started: "Itin√©raire d√©marr√© üèÅ"
        open_gate: "Ouvrir portail ? üîì"
        close_gate: "Fermer portail ? üîê"
        timer_opening: "Ouverture portail dans {{timer_opening}}s üîì"
        timer_closing: "Fermeture portail dans {{timer_closing}}s üîê"
        gate_reopening: "R√©ouverture portail üîì"
        itinerary_canceled: "Itin√©raire annul√© ‚ùå"
        awaiting: "Portail en attente de {awaited_persons} üí§"
        disabled: "Automatic Gate d√©sactiv√© üö´"
        valid_config: "{{blueprint_name}}: Configuration valide üõ†Ô∏è‚úÖ"
        invalid_config: "{{blueprint_name}}: Configuration invalide üõ†Ô∏è‚ùå"
      message:
        leaving_home: "Vous sortez de la maison"
        vehicle_started: "Vous avez d√©marr√© votre v√©hicule"
        soon_arrived: "Vous arrivez bient√¥t"
        arrived: "Vous √™tes arriv√©"
        closing_suggestion: "{{suggest_closing_after}} secondes se sont √©coul√©es"
        ble_out_of_range: "Votre appareil BLE est hors de port√©e"
        awaiting: "Le portail se refermera une fois tous les conducteurs entr√©s/sortis"
        something_went_wrong: "Un probl√®me est survenu ! Le blueprint s'est arr√™t√© de mani√®re inattendue."
        vehicle_stopped: "Le v√©hicule a √©t√© arr√™t√©"
        canceling_order: "Vous avez appuy√© sur le bouton annuler"
        did_not_leave: "Le v√©hicule n'est pas sorti en moins de {{safety_delay}} minutes"
        did_not_arrive: "Le v√©hicule n'est pas arriv√© en moins de {{safety_delay}} minutes"
        timed_out: "Votre position n'a pas √©t√© mise √† jour ces {{timeout_delay}} derni√®res minutes"
        vehicle_away: "Le v√©hicule n'est pas dans la zone d'ouverture"
        travel_time_did_not_respond: "Votre int√©gration de temps de trajet n'a pas renvoy√© de valeur"
        not_home: "Le v√©hicule n'est pas √† la maison"
        location_not_confirmed: "Votre localisation n'a pas pu √™tre confirm√©e"
        got_no_gps_data: "Votre t√©l√©phone est joignable, mais ne renvoie pas sa localisation ! V√©rifiez que le capteur 'Emplacement pr√©cis unique' est activ√©."
        gate_closed: "Le portail a √©t√© ferm√© manuellement"
        triggered_frequently: "L'automatisation se d√©clenche √† r√©p√©tition !"
        disabled_triggered_frequently: |-
          L'automation s'est d√©clench√©e {quick_triggers} fois d'affil√©e
          R√©activez l'automatisation manuellement une fois le probl√®me corrig√©
        disabled_updated_frequently: |-
          L'automatisation a satur√© l'API de temps de trajet avec des requ√™tes trop rapides
          Signalez ce probl√®me sur GitHub svp !
        forbidden_zone: "Vous √™tes entr√© dans une zone interdite"
        invalid_travel_time_sensor: "Votre capteur de temps de trajet n'existe pas !"
        unsupported_tt_integration: "Votre int√©gration de temps de trajet n'est pas support√©e !"
        too_close: "Vous avez d√©marr√© trop pr√®s de la zone du portail"
        valid_config: "Votre configuration semble valide"
        more_info: "Plus d'infos"
        invalid_translations: "Vos traductions personnalis√©es ne sont pas valides. V√©rifiez les valeurs suivantes: '{data}'. (#1)"
        missing_ble_entities: "Vous n'avez pas entr√© de scanner BLE (#2)"
        ble_not_used: "Vous avez entr√© ces scanners BLE: '{data}' mais ne les utilisez pas (#3)"
        missing_wifi_trackers: "Vous n'avez pas entr√© de traceurs Wi-Fi (#4)"
        wifi_not_used: "Vous avez entr√© ces traceurs Wi-Fi: '{data}' mais ne les utilisez pas (#5)"
        missing_gps_data: "Ces traceurs/personnes: '{data}' ne prend pas en charge le suivi GPS (#6)"
        ble_not_unknown: "Ces traceurs BLE: '{data}' sont actuellement dans un √©tat diff√©rent de 'unknown'. Si vous vous trouvez actuellement √† proximit√©, vous pouvez ignorer cette erreur. (#7)"
        missing_arrival_opening_method: "Vous n'avez aucune m√©thode pour d√©tecter votre arriv√©e. Ajoutez un capteur de temps de trajet ou utilisez un traceur BLE. (#8)"
        too_many_arrival_opening_method: "Vous utilisez plusieurs m√©thodes pour d√©tecter votre arriv√©e. Une seule suffit. (#9)"
        invalid_itinerary_sensor_length: "Ces capteurs d'itin√©raire: '{data}' ont une longueur maximale inf√©rieure √† 255 (#10)"
        invalid_per_person_sensors: "Vous n'avez pas entr√© le bon nombre de capteurs dans les champs de capteurs par personne (#11)"
        per_person_sensors_mismatch: "Ces personnes: '{data}' semblent avoir des capteurs par personne m√©lang√©s (#12)"
        no_gate_area: "Vous utilisez des traceurs BLE par pi√®ce de maison: '{data}' mais votre portail n'a pas √©t√© plac√© dans une pi√®ce (#13)"
        wifi_tracker_is_gps: "Ces traceurs: '{data}' sont de type GPS au lieu de Routeur (#14)"
        invalid_ibeacon_transmitter: "Ces transmetteurs iBeacon: '{data}' sont invalides (#19)"
        no_compatible_gps_tracker: "Ces personnes ne pourront pas √™tre attendue en GPS: '{data}' car elle n'ont pas de traceurs gps, ou ils proviennent d'une application diff√©rente de celle de l'appareil de notification (#20)"
        deprecated_translations: "Les traductions personnalis√©s utilisent maintenant un dictionnaire yaml au lieu de json. Mettez √† jour votre configuration svp. (#21)"
      button:
        open: "Ouvrir üîì"
        close: "Fermer üîê"
        cancel: "Annuler ‚ùå"

triggers:
  - alias: Trigger when user connects to vehicle
    trigger: state
    id: vehicle_started
    entity_id: !input driving_sensors
    from: "off"
    to: "on"
  - alias: Trigger when the blueprint the user added the blueprint, updated inputs, or HA started
    trigger: template
    id: blueprint_enabled
    value_template: "{{ is_state(this.entity_id, 'on') }}"
    enabled: !input run_checks_when_enabled

conditions: []

actions:
  - alias: If the blueprint was triggered by a driving sensor
    if:
      - condition: trigger
        id: vehicle_started
    then:
      - alias: Set variables containing data related to the driver
        variables:
          idx: "{{ driving_sensors.index(trigger.entity_id) }}"
          person: |-
            {% if idx < persons | length %}
              {{ persons[idx] }}
            {% elif persons | length == 1 %}
              {{ persons[0] }}
            {% else %}
              {{ none }}
            {% endif %}
          driving_sensor: "{{ trigger.entity_id }}"
          travel_time_sensor: |-
            {% if travel_time_sensors | length > idx %}
              {{ travel_time_sensors[idx] }}
            {% else %}
              {{ none }}
            {% endif %}
          notify_service: |-
            {% if notify_services | length > idx %}
              {{ notify_services[idx] }}
            {% else %}
              {{ none }}
            {% endif %}
          ios_device: |-
            {{
              false if notify_service is none
              else device_attr(notify_devices[idx], 'manufacturer') == 'Apple'
            }}
          itinerary_sensor: "{{ itinerary_sensors[idx] }}"
          itinerary_value: |-
            {%
              set state = (
                states(itinerary_sensor)
                | from_json(default_itinerary_sensor_value)
              )
            %}
            {%
              if default_itinerary_sensor_value.keys() == state.keys()
            %}
              {{ state }}
            {% else %}
              {{ default_itinerary_sensor_value }}
            {% endif %}
          ble_transmitter_entity: |-
            {{
              ble_transmitter_entities[idx]
              if ble_transmitter_entities | length > idx
              else none
            }}
  - alias: Initialize variables for the error checker
    variables:
      messages: []
      custom_translations_error: "{{ custom_translations is not mapping }}"
      successful_check: false
      error_level: 0
  - alias: If the custom translations is not a mapping
    if:
      - condition: template
        value_template: "{{ custom_translations_error }}"
    then:
      - alias: Reset the custom translations
        variables:
          custom_translations: {}

    ##################
    # ERROR CHECKING #
    ##################
  - alias: If the config checker should run checks
    if:
      - condition: or
        conditions:
          - alias: If the blueprint was executed manually
            condition: template
            value_template: "{{ trigger.platform is none }}"
          - alias: If checks should be run when triggered by a driving sensor
            condition: and
            conditions:
              - condition: trigger
                id: vehicle_started
              - condition: template
                value_template: !input always_run_checks
          - alias: If the user added the blueprint, updated inputs, or HA started
            condition: trigger
            id: blueprint_enabled
    then:
      - alias: Check for errors
        repeat:
          for_each:
            - alias: Check custom translations
              error: |-
                {% set data = namespace(invalid=[]) %}
                {% for key, sub_items in custom_translations.items() %}
                  {% if key not in strings['en'] %}
                    {% set data.invalid = data.invalid + [key] %}
                  {% else %}
                    {% for subkey, value in sub_items.items() %}
                      {%
                        if value is not string
                        or subkey not in strings['en'][key]
                      %}
                        {% set data.invalid = data.invalid + [subkey] %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}
                {% endfor %}
                {{ data.invalid }}
              message_id: "invalid_translations"
              level: 1
            - alias: Check missing ble sensors
              error: |-
                {{
                  (
                    'ble' in (
                      only_open_near
                      + open_when_connected_to
                      + close_when_disconnected_from
                    )
                    or ble_transmitter_entities | length > 0
                    or ble_scanner_switch != ""
                  )
                  and ble_entities | length == 0
                }}
              message_id: "missing_ble_entities"
              level: 2
            - alias: Check that ble is used if a device is set
              error: |-
                {%
                  if ble_entities | length > 0 and (
                    'ble' not in (
                      only_open_near
                      + open_when_connected_to
                      + close_when_disconnected_from
                    )
                  )
                %}
                  {{
                    ble_entities
                    | map('state_attr', 'friendly_name')
                    | list
                  }}
                {% else %}
                  {{ false }}
                {% endif %}
              message_id: "ble_not_used"
              level: 0
            - alias: Check missing wifi sensors
              error: |-
                {{
                  'wifi' in only_open_near
                  and wifi_devices | length == 0
                }}
              message_id: "missing_wifi_trackers"
              level: 1
            - alias: Check that wifi is used if a device is set
              error: |-
                {%
                  if (
                    wifi_devices | length > 0
                    and 'wifi' not in only_open_near
                  )
                %}
                  {{
                    wifi_devices
                    | map('state_attr', 'friendly_name')
                    | list
                  }}
                {% else %}
                  {{ false }}
                {% endif %}
              message_id: "wifi_not_used"
              level: 0
            - alias: Check that device trackers contain GPS data
              error: |-
                {% set data = namespace(invalid=[]) %}
                {% for tracker in persons %}
                  {% set original_entity = tracker %}
                  {% if states[tracker].domain == 'person' %}
                    {% set tracker = state_attr(tracker, 'source') %}
                  {% endif %}
                  {%
                    if tracker is none
                    or not is_state_attr(tracker, 'source_type', 'gps')
                  %}
                    {% set data.invalid = data.invalid + [original_entity] %}
                  {% endif %}
                {% endfor %}
                {{
                  data.invalid
                  | map('state_attr', 'friendly_name')
                  | list
                }}
              message_id: "missing_gps_data"
              level: 2
            - alias: Check that signal strength BLE devices report unknown by default
              error: |-
                {% if trigger.platform is none %}
                  {{
                    ble_entities
                    | expand
                    | selectattr(
                      'attributes.device_class',
                      'in',
                      ['signal_strength', 'distance']
                    )
                    | map(attribute='entity_id')
                    | select('is_state', 'unknown')
                    | map('state_attr', 'friendly_name')
                    | list
                  }}
                {% else %}
                  {{ false }}
                {% endif %}
              message_id: "ble_not_unknown"
              level: 1
            - alias: Check that the user entered a sensor to detect his arrival
              error: |-
                {{
                  travel_time_sensors | length == 0
                  and 'ble' not in open_when_connected_to
                }}
              message_id: "missing_arrival_opening_method"
              level: 2
            - alias: Check that the user uses only one way to detect his arrival
              error: |-
                {{
                  travel_time_sensors | length > 0
                  and 'ble' in open_when_connected_to
                }}
              message_id: "too_many_arrival_opening_method"
              level: 0
            - alias: Check that itinerary sensors have a valid maximum length
              error: |-
                {{
                  itinerary_sensors
                  | expand
                  | selectattr('attributes.max', 'lessthan', 255)
                  | map(attribute='name')
                  | list
                }}
              message_id: "invalid_itinerary_sensor_length"
              level: 2
            - alias: Check that all per person sensors have been entered
              error: |-
                {% set persons_len = persons | length %}
                {% set driving_len = driving_sensors | length %}
                {{
                  not(
                    (
                      persons_len == 1
                      or persons_len == driving_len
                    )
                    and (
                      driving_len
                      <= itinerary_sensors | length
                    )
                    and (
                      persons_len == travel_time_sensors | length
                      or 'ble' in open_when_connected_to
                    )
                    and wifi_devices | length <= driving_len
                    and ble_entities | length <= driving_len
                    and ble_transmitter_entities | length <= driving_len
                  )
                }}
              message_id: "invalid_per_person_sensors"
              level: 2
            - alias: Check that per person sensors are in the right order
              error: |-
                {%
                  set per_person_phone_sensors = [
                    driving_sensors,
                    ble_transmitter_entities,
                    wifi_devices
                  ]
                %}
                {% set data = namespace(invalid=[], entities_to_check=[]) %}
                {% for device_idx in range(notify_devices | length) %}
                  {% set data.entities_to_check = [] %}
                  {% set related_entities = device_entities(
                      notify_devices[device_idx]
                    )
                  %}
                  {% for checker_idx in range(notify_devices | length) %}
                    {% if device_idx == checker_idx %}
                      {% continue %}
                    {% endif %}

                    {# Append device trackers to the list #}
                    {% if checker_idx < persons | length %}
                      {% set trackers = [persons[checker_idx]] %}
                      {% if states[trackers[0]].domain == 'person' %}
                        {% set trackers = state_attr(trackers[0], 'device_trackers') %}
                      {% endif %}
                      {% set data.entities_to_check = data.entities_to_check + trackers %}
                    {% endif %}

                    {# Append all other per person sensors #}
                    {% for sensors in per_person_phone_sensors %}
                      {% if sensors | length > checker_idx %}
                        {%
                          set data.entities_to_check = (
                            data.entities_to_check
                            + [sensors[checker_idx]]
                          )
                        %}
                      {% endif %}
                    {% endfor %}
                  {% endfor %}

                  {# Append sensors belonging to the wrong users #}
                    {%
                      if (
                        data.entities_to_check
                        | select('in', related_entities)
                        | list
                        | length
                        != 0
                      )
                    %}
                      {%
                        if persons | length == 1 < driving_sensors | length
                        and device_idx < itinerary_sensors | length
                      %}
                        {% set new_invalid = itinerary_sensors[device_idx] %}
                      {% elif device_idx < persons | length %}
                        {% set new_invalid = persons[device_idx] %}
                      {% else %}
                        {% set new_invalid = 'Unknown' %}
                      {% endif %}
                      {% set data.invalid = data.invalid + [new_invalid] %}
                    {% endif %}
                {% endfor %}
                {{
                  data.invalid
                  | map('state_attr', 'friendly_name')
                  | list
                }}
              message_id: "per_person_sensors_mismatch"
              level: 2
            - alias: Check that at least one gate has an area attached if a ble tracker uses area tracking
              error: |-
                {% if gate_areas | length < 1 %}
                  {{
                    ble_entities
                    | select('is_state_attr', 'device_class', 'bermuda__custom_device_class')
                    | map('state_attr', 'friendly_name')
                    | list
                  }}
                {% else %}
                  {{ false }}
                {% endif %}
              message_id: "no_gate_area"
              level: 2
            - alias: Check that Wi-Fi device trackers does not contain GPS data
              error: |-
                {{
                  wifi_devices
                  | expand
                  | selectattr('attributes.source_type', 'equalto', 'gps')
                  | map(attribute='name')
                  | list
                }}
              message_id: "wifi_tracker_is_gps"
              level: 1
            - alias: Check that iBeacon transmitters are valid
              error: |-
                {{
                  ble_transmitter_entities
                  | expand
                  | rejectattr('attributes.options', 'contains', 'Transmitting')
                  | map(attribute='attributes.friendly_name')
                  | list
                }}
              message_id: "invalid_ibeacon_transmitter"
              level: 2
            - alias: Check that gps trackers are compatible if the location must be confirmed with gps
              error: |-
                {% if 'gps' in only_open_near %}
                  {% set data = namespace(invalid=[]) %}
                  {% for person_idx in range(persons | length) %}
                    {% if states[persons[person_idx]].domain == 'person' %}
                      {% set trackers = state_attr(persons[person_idx], 'device_trackers') %}
                      {% if trackers is none %}
                        {% set trackers = [] %}
                      {% endif %}
                    {% else %}
                      {% set trackers = [persons[person_idx]] %}
                    {% endif %}
                    {%
                      set gps_trackers = (
                        trackers
                        | select('is_state_attr', 'source_type', 'gps')
                        | list
                      )
                    %}
                    {%
                      set wait_for_mobile_gps = (
                        person_idx < notify_devices | length
                        and (
                          gps_trackers
                          | select(
                            'in',
                            device_entities(
                              notify_devices[person_idx]
                            )
                          )
                          | list
                          | length
                          > 0
                        )
                      )
                    %}
                    {% set gps = namespace(not_mobile=[]) %}
                    {% for tracker in gps_trackers %}
                      {% set ids = device_attr(tracker, 'identifiers') %}
                      {%
                        if ids is none
                        or ids | first | first != 'mobile_app'
                      %}
                        {% set gps.not_mobile = gps.not_mobile + [tracker] %}
                      {% endif %}
                    {% endfor %}
                    {%
                      if gps.not_mobile | length < 1
                      and not wait_for_mobile_gps
                    %}
                      {% set data.invalid = data.invalid + [persons[person_idx]] %}
                    {% endif %}
                  {% endfor %}
                  {{
                    data.invalid
                    | map('state_attr', 'friendly_name')
                    | list
                  }}
                {% else %}
                  {{ false }}
                {% endif %}
              message_id: "no_compatible_gps_tracker"
              level: 1
            - alias: Check custom translations depreciation
              error: "{{ custom_translations_error }}"
              message_id: "deprecated_translations"
              level: 0
          sequence:
            - alias: If a check failed
              if:
                - condition: template
                  value_template: |-
                    {% set error = repeat.item.error %}
                    {{ error != [] if error is list else error }}
              then:
                - alias: If the error level is higher than the current highest
                  if:
                    - condition: template
                      value_template: "{{ repeat.item.level > error_level }}"
                  then:
                    - alias: Save the new highest error level
                      variables:
                        error_level: "{{ repeat.item.level }}"
                - alias: Get notification translation
                  variables:
                    message_id: "{{ repeat.item.message_id }}"
                    message: &get_message |-
                      {# Custom translation #}
                      {%
                        if 'message' in custom_translations
                        and message_id in custom_translations['message']
                      %}
                        {{ custom_translations['message'][message_id] }}

                      {# Selected language #}
                      {% elif message_id in strings[language]['message'] %}
                        {{ strings[language]['message'][message_id] }}

                      {# Fallback to english #}
                      {% else %}
                        {{ strings['en']['message'][message_id] }}
                      {% endif %}
                - alias: If the error variable contains a list
                  if:
                    - condition: template
                      value_template: "{{ repeat.item.error is list }}"
                  then:
                    - alias: Format the string with error data
                      variables:
                        message: |-
                          {{
                            message.format(
                              data=(
                                ', '.join(repeat.item.error)
                              )
                            )
                          }}
                - alias: Append the error message to the list
                  variables:
                    messages: "{{ messages | union([message]) }}"
      - alias: If the config is valid
        if:
          - condition: template
            value_template: "{{ messages | length == 0 }}"
        then:
          - alias: If the blueprint was triggered manually
            if:
              - condition: template
                value_template: "{{ trigger.platform is none }}"
            then:
              - alias: Set message ids
                variables:
                  title_id: "valid_config"
                  message_id: "valid_config"
              - alias: Get notification translation
                variables: &get_translation
                  message: *get_message
                  title: &get_title |-
                    {# Custom translation #}
                    {%
                      if 'title' in custom_translations
                      and title_id in custom_translations['title']
                    %}
                      {%
                        set title_string = (
                          custom_translations['title'][title_id]
                        )
                      %}

                    {# Selected language #}
                    {% elif title_id in strings[language]['title'] %}
                      {%
                        set title_string = (
                          strings[language]['title'][title_id]
                        )
                      %}

                    {# Fallback to english #}
                    {% else %}
                      {%
                        set title_string = (
                          strings['en']['title'][title_id]
                        )
                      %}
                    {% endif %}
                    {{
                      title_string.format(
                        awaited_persons=awaited_persons
                      )
                    }}
              - alias: Notify all users on the dashboard that the config is valid
                action: persistent_notification.create
                data:
                  title: "{{ title }}"
                  message: "{{ message }}"
                  notification_id: "{{ config_checker_tag }}"
            else:
              - alias: Remove the previous dashboard notification
                action: persistent_notification.dismiss
                data:
                  notification_id: "{{ config_checker_tag }}"
        else:
          - alias: Build the notification
            variables:
              title_id: "invalid_config"
              title: *get_title
              message: "{{ '‚Ä¢ ' ~ '\n‚Ä¢ '.join(messages) }}"
          - alias: Build the more info link
            variables:
              message_id: "more_info"
              more_info: *get_message
              link: "https://github.com/etiennec78/Home-Automation/tree/master/Blueprints/README.md#error-codes-table-%EF%B8%8F"
              more_info_md: "[{{more_info}}]({{link}})"
          - alias: Notify all users on the dashboard that the config is invalid
            action: persistent_notification.create
            data:
              title: "{{ title }}"
              message: "{{ message ~ '\n\n' ~ more_info_md }}"
              notification_id: "{{ config_checker_tag }}"
          - alias: If the blueprint was not triggered manually
            if:
              - condition: template
                value_template: "{{ trigger.platform is not none }}"
            then:
              - alias: If a notify service exists
                if:
                  - condition: template
                    value_template: "{{ notify_service is not none }}"
                then:
                  - alias: Notify the driver that his config is invalid
                    action: "{{ notify_service }}"
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                      data:
                        car_ui: true
                        notification_icon: mdi:hammer-wrench
                        channel: Automatic Gate
                        group: Automatic Gate
                        importance: high
                        priority: high
                        ttl: 0
                        push:
                          sound:
                            name: "default"
                            critical: 1
                        tag: "{{ config_checker_tag }}"
                  - sequence: &tts
                      - alias: Notify over TTS
                        action: "{{ notify_service }}"
                        data:
                          message: TTS
                          data:
                            tts_text: |-
                              {%
                                set clean_title = (
                                  title
                                    | regex_replace('[\u2600-\u26FF]', '')
                                    | regex_replace('[\u2700-\u27BF]', '')
                                    | regex_replace('[\U0001F300-\U0001F5FF]', '')
                                    | regex_replace('[\U0001F600-\U0001F64F]', '')
                                    | regex_replace('[\U0001F680-\U0001F6FF]', '')
                                ).strip()
                              %}
                              {% set separator = ' ' if clean_title[-1] in ['.', '!', '?'] else '. ' %}
                              {{ clean_title ~ separator ~ message }}
                            channel: Itinerary status
                            importance: high
                            priority: high
                            ttl: 0
                            media_stream: !input phone_tts_stream
                        enabled: !input phone_tts
      - alias: Confirm that no error occured while the config checker was running
        variables:
          successful_check: true
    else:
      - alias: Mark the check as successful since it did not happen
        variables:
          successful_check: true
    continue_on_error: true
  - alias: If an error occured while the config checker was running
    if:
      - condition: template
        value_template: "{{ not successful_check }}"
    then:
      - alias: Set notification ids
        variables:
          title_id: "invalid_config"
          message_id: "something_went_wrong"
      - alias: Get notification translation
        variables: *get_translation
      - alias: Notify all users on the dashboard that an error occured
        action: persistent_notification.create
        data:
          title: "{{ title }}"
          message: "{{ message }}"
          notification_id: "{{ config_checker_tag }}"
      - stop: Config checker failed
        error: true
  - alias: Only continue if the blueprint was triggered by a driving sensor and tests passed
    condition: template
    value_template: |-
      {{
        trigger.platform is not none
        and trigger.id == 'vehicle_started'
        and successful_check
        and error_level < 2
      }}
  - alias: If last automation iteration ended less than 5s ago
    if:
      - condition: template
        value_template: "{{ states[itinerary_sensor].last_updated + timedelta(seconds=5) > now() }}"
    then:
      - alias: Update the quick triggers counter
        variables:
          update:
            status: "{{ none }}"
            error: "triggered_frequently"
            quick_triggers: "{{ itinerary_value.quick_triggers + 1 }}"
          itinerary_value: "{{ dict(itinerary_value, **update) }}"
      - alias: Save the quick triggers counter
        action: input_text.set_value
        target:
          entity_id: "{{ itinerary_sensor }}"
        data:
          value: "{{ itinerary_value | to_json }}"
      - alias: Save if the blueprint recently tried closing the gate
        variables:
          tried_closing_recently: |-
            {{
              itinerary_value.last_closed
                | as_datetime
                + timedelta(seconds=lead_time)
                > now()
            }}
      - choose:
          - alias: If the gate may be closing on the driver
            conditions:
              - condition: template
                value_template: "{{ tried_closing_recently }}"
              - alias: If the user wants his gate to reopen if the driving sensor quickly triggers
                condition: template
                value_template: !input quick_triggers_reopen_gate
              - alias: If the gate was not closed manually
                condition: template
                value_template: "{{ itinerary_value.auto_closed }}"
              - alias: If one of the gates is closing/closed
                condition: template
                value_template: &gate_open |-
                  {{
                    gate
                    | select('is_state', ['on', 'open', 'opening'])
                    | list
                    != []
                  }}
            sequence:
              - alias: Reopen each gate to avoid closing on the driver
                repeat: &open_gates
                  for_each: "{{ gate | select('is_state', ['off', 'closed', 'closing']) | list }}"
                  sequence:
                    - action: |-
                        {% if states[repeat.item].domain == 'switch' %}
                          switch.turn_on
                        {% elif states[repeat.item].domain == 'cover' %}
                          cover.open_cover
                        {% endif %}
                      target:
                        entity_id: "{{ repeat.item }}"
              - alias: Set notification ids
                variables:
                  title_id: "gate_reopening"
                  message_id: "triggered_frequently"
              - alias: Get notification translation
                variables: *get_translation
              - alias: Log error
                action: system_log.write
                data:
                  level: error
                  message: "{{ message }}"
                  logger: blueprints.etiennec78.automatic_gate
              - alias: If a notify service exists
                if:
                  - condition: template
                    value_template: "{{ notify_service is not none }}"
                then:
                  - alias: Notify driver that the gate is reopening
                    action: "{{ notify_service }}"
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                      data: &notification_data
                        car_ui: true
                        notification_icon: mdi:alert-circle
                        color: "#00bcd4"
                        channel: Itinerary Status
                        group: Itinerary Status
                        importance: high
                        priority: high
                        ttl: 0
                        push:
                          sound:
                            name: "default"
                            critical: 1
                        tag: itinerary-status
                  - sequence: *tts
              - stop: Blueprint triggered closing on the user
                error: true
          - alias: If this is the third time the error occurs in a row
            conditions:
              - condition: template
                value_template: "{{ itinerary_value.quick_triggers >= 3 }}"
            sequence:
              - alias: Set error id
                variables:
                  message_id: "disabled_triggered_frequently"
              - alias: Disable the blueprint
                sequence: &disable_blueprint
                  - alias: Get title id
                    variables:
                      title_id: "disabled"
                  - alias: Get notification translation
                    variables: *get_translation
                  - alias: Format the error message
                    variables:
                      message: |-
                        {{
                          message.format(
                            quick_triggers=itinerary_value.quick_triggers
                          )
                        }}
                  - alias: Log error
                    action: system_log.write
                    data:
                      level: error
                      message: "{{ message }}"
                      logger: blueprints.etiennec78.automatic_gate
                  - alias: If a notify service exists
                    if:
                      - condition: template
                        value_template: "{{ notify_service is not none }}"
                    then:
                      - alias: Notify driver that the blueprint is disabling itself
                        action: "{{ notify_service }}"
                        data:
                          title: "{{ title }}"
                          message: "{{ message }}"
                          data: *notification_data
                      - sequence: *tts
                  - alias: Notify all users on the dashboard that the blueprint has disabled itself
                    action: persistent_notification.create
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                  - alias: Disable the blueprint
                    action: automation.turn_off
                    target:
                      entity_id: "{{ this.entity_id }}"
          - alias: If the gate recently tried to close but the gate does not need to reopen
            conditions:
              - condition: template
                value_template: "{{ tried_closing_recently }}"
            sequence:
              - alias: Set notification ids
                variables:
                  title_id: "itinerary_canceled"
                  message_id: "triggered_frequently"
              - alias: Get notification translation
                variables: *get_translation
              - alias: Log error
                action: system_log.write
                data:
                  level: error
                  message: "{{ message }}"
                  logger: blueprints.etiennec78.automatic_gate
              - alias: If a notify service exists
                if:
                  - condition: template
                    value_template: "{{ notify_service is not none }}"
                then:
                  - alias: Notify driver of itinerary cancelation
                    action: "{{ notify_service }}"
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                      data: *notification_data
                  - sequence: *tts
              - stop: The gate recently tried to close
    else:
      - alias: If the quick triggers counter is not at 0
        if:
          - condition: template
            value_template: "{{ itinerary_value.quick_triggers != 0 }}"
        then:
          - alias: Reset the quick triggers counter
            variables:
              update:
                error: "{{ none }}"
                quick_triggers: 0
              itinerary_value: "{{ dict(itinerary_value, **update) }}"
          - alias: Save the quick triggers counter
            action: input_text.set_value
            target:
              entity_id: "{{ itinerary_sensor }}"
            data:
              value: "{{ itinerary_value | to_json }}"
  - alias: If there is no notification service
    if:
      - condition: template
        value_template: "{{ notify_service is none }}"
    then:
      alias: Change behaviors needing a notification service to auto
      variables:
        behavior: |-
          {% set data = namespace(behaviors={}) %}
          {% for key, val in behavior.items() %}
            {% set inner = namespace(value={}) %}
            {% for subkey, subval in val.items() %}
              {% set inner.value = inner.value | combine({
                subkey: 'auto' if subval in ['notif', 'timer'] else subval
              }) %}
            {% endfor %}
            {% set data.behaviors = data.behaviors | combine({ key: inner.value }) %}
          {% endfor %}
          {{ data.behaviors }}
  - alias: Get which sensor the blueprint should wait to confirm the driver's presence
    variables:
      gps_trackers: |-
        {% if states[person].domain == 'person' %}
          {% set trackers = state_attr(person, 'device_trackers') %}
          {% if trackers is none %}
            {% set trackers = [] %}
          {% endif %}
        {% else %}
          {% set trackers = [person] %}
        {% endif %}
        {{
          trackers
          | select('is_state_attr', 'source_type', 'gps')
          | list
        }}
      wait_for_mobile_gps: |-
        {{
          notify_service is not none
          and (
            gps_trackers
            | select(
              'in',
              device_entities(
                notify_devices[idx]
              )
            )
            | list
            | length
            > 0
          )
        }}
      other_gps_to_wait_for: |-
        {% set data = namespace(not_mobile=[]) %}
        {% for tracker in gps_trackers %}
          {% set ids = device_attr(tracker, 'identifiers') %}
          {%
            if ids is none
            or ids | first | first != 'mobile_app'
          %}
            {% set data.not_mobile = data.not_mobile + [tracker] %}
          {% endif %}
        {% endfor %}
        {{ data.not_mobile }}
      wait_for_gps: |-
        {{
          'gps' in only_open_near
          and (
            wait_for_mobile_gps
            or other_gps_to_wait_for | length > 0
          )
        }}
      wait_for_wifi: "{{ 'wifi' in only_open_near and wifi_devices | length > idx }}"
      wait_for_ble: "{{ 'ble' in only_open_near and ble_entities | length > idx }}"
      ble_started: "{{ false }}"
  - alias: Get whether the user is leaving or arriving
    variables: &get_itinerary_mode
      departure: |-
        {{
          is_state(
            person, [
              state_attr(gate_location, 'friendly_name'),
              states[gate_location].object_id
            ]
          )
        }}
      eta_zone: &activation_zone_in_condition |-
        {% if state_attr(person, 'gps_accuracy') is none %}
          {% set accuracy = 100 %}
        {% else %}
          {% set accuracy = state_attr(person, 'gps_accuracy') %}
        {% endif %}
        {% set gate_distance = distance(person, gate_location)*1000 - accuracy %}

        {{ gate_distance < activation_zone }}
      arrival: "{{ not eta_zone }}"
  - alias: If the user wants to confirm his presence before starting the blueprint
    if:
      - condition: template
        value_template: |-
          {{
            wait_for_gps
            or departure and (
              wait_for_wifi
              or wait_for_ble
            )
          }}
    then:
      - alias: Store values for the next sequence
        variables:
          start_timestamp: "{{ now() | as_timestamp }}"
          received_timestamp: "{{ none }}"
          old_location_id: "{{ states[person].context.id }}"
          gates_were_opened: &all_gates_open |-
            {{
              gate
              | select('is_state', ['on', 'open', 'opening'])
              | list
              == gate
            }}
          lock_departure: false
          gps_confirmed: |-
            {{
              states[person].last_updated
              + timedelta(seconds=gps_outdated_delay)
              >= now()
            }}
      - alias: If the GPS request on startup is enabled and the location is outdated
        if:
          - condition: template
            value_template: "{{ wait_for_gps and not gps_confirmed }}"
        then:
          - alias: If one of the device trackers related to the driver is his phone
            if:
              - condition: template
                value_template: "{{ wait_for_mobile_gps }}"
            then:
              - alias: Update the driver's location with a mobile app location request
                action: "{{ notify_service }}"
                data:
                  message: request_location_update
                  data:
                    tag: "gps-request-{{this.attributes.id}}"
                    priority: high
                    importance: high
                    confirmation: true
          - alias: Update the driver's location by refreshing his gps device trackers
            action: homeassistant.update_entity
            data:
              entity_id: "{{ other_gps_to_wait_for }}"
      - alias: If a BLE tracker has been provided
        if:
          - condition: template
            value_template: "{{ departure and wait_for_ble }}"
        then:
          - alias: Update the BLE tracker
            action: homeassistant.update_entity
            data:
              entity_id: "{{ ble_entities[idx] }}"
      - alias: If a wifi tracker has been provided
        if:
          - condition: template
            value_template: "{{ departure and wait_for_wifi }}"
        then:
          - alias: Update the Wi-Fi device tracker
            action: homeassistant.update_entity
            data:
              entity_id: "{{ wifi_devices[idx] }}"
      - alias: Repeat while the location has not been confirmed
        repeat:
          while:
            - condition: template
              value_template: |-
                {{
                  not (
                    gps_confirmed and (
                      arrival
                      or not wait_for_wifi and not wait_for_ble
                    )
                    or departure
                    and (
                      wait_for_ble and (
                        states(ble_entities[idx]) | is_number
                        or is_state(ble_entities[idx], 'home')
                        or state_attr(ble_entities[idx], 'area_id') in gate_areas
                      )
                      or wait_for_wifi and (
                        states(wifi_devices[idx]) | is_number
                        or is_state(wifi_devices[idx], 'home')
                      )
                    )
                  )
                }}
          sequence:
            - alias: If the user is on departure and BLE devices should turn on
              if:
                - condition: template
                  value_template: "{{ departure and wait_for_ble }}"
              then: &start_ble
                - alias: Only continue if BLE devices were not already started
                  condition: template
                  value_template: "{{ not ble_started }}"
                - alias: Initialize BLE related variables
                  variables:
                    ble_started: true
                    ibeacon_restore_messages: []
                    scanner_turned_on: false
                - alias: If the driver has a transmitter entity and a notification device set
                  if:
                    - condition: template
                      value_template: |-
                        {{
                          notify_service is not none
                          and ble_transmitter_entity is not none
                        }}
                  then:
                    - alias: Check for incorrect iBeacon transmitter states
                      repeat:
                        for_each:
                          - alias: Check that bluetooth is on
                            condition: |-
                              {{
                                is_state(
                                  ble_transmitter_entity,
                                  'Bluetooth is turned off'
                                )
                              }}
                            message: command_bluetooth
                            message_data:
                              command: turn_on
                            restore_message_data:
                              command: turn_off
                          - alias: Check that the iBeacon transmitter is on
                            condition: |-
                              {{
                                is_state(
                                  ble_transmitter_entity,
                                  ['Stopped', 'Bluetooth is turned off']
                                )
                              }}
                            message: command_ble_transmitter
                            message_data:
                              command: turn_on
                            restore_message_data:
                              command: turn_off
                          - alias: Check for the transmitting power
                            condition: |-
                              {{
                                not is_state_attr(
                                  ble_transmitter_entity,
                                  'Transmitting power',
                                  'high'
                                )
                              }}
                            message: command_ble_transmitter
                            message_data:
                              command: ble_set_transmit_power
                              ble_transmit: ble_transmit_high
                            restore_message_data:
                              command: ble_set_transmit_power
                              ble_transmit: |-
                                {{
                                  'ble_transmit_' ~ (
                                    state_attr(
                                      ble_transmitter_entity,
                                      'Transmitting power'
                                    )
                                    | regex_replace('([a-z])([A-Z])', '\\1_\\2')
                                    | lower
                                  )
                                }}
                          - alias: Check for the advertising mode
                            condition: |-
                              {{
                                not is_state_attr(
                                  ble_transmitter_entity,
                                  'Advertise mode',
                                  'lowLatency'
                                )
                              }}
                            message: command_ble_transmitter
                            message_data:
                              command: ble_set_advertise_mode
                              ble_advertise: ble_advertise_low_latency
                            restore_message_data:
                              command: ble_set_advertise_mode
                              ble_advertise: |-
                                {{
                                  'ble_advertise_' ~ (
                                    state_attr(
                                      ble_transmitter_entity,
                                      'Advertise mode'
                                    )
                                    | regex_replace('([a-z])([A-Z])', '\\1_\\2')
                                    | lower
                                  )
                                }}
                        sequence:
                          - alias: Only continue if the state is incorrect
                            condition: template
                            value_template: "{{ repeat.item.condition }}"
                          - alias: Send a request to the phone to fix its iBeacon state
                            action: "{{ notify_service }}"
                            data:
                              message: "{{ repeat.item.message }}"
                              data: |-
                                {{
                                  repeat.item.message_data
                                  | combine(
                                    {
                                      'importance': 'high',
                                      'priority':'high'
                                    }
                                  )
                                }}
                          - alias: Add a message to send to the phone when the iBeacon states need to be restored
                            variables:
                              ibeacon_restore_messages: |-
                                {{
                                  ibeacon_restore_messages
                                  + [{
                                    'message': repeat.item.message,
                                    'data': repeat.item.restore_message_data
                                  }]
                                }}
                - alias: If the BLE scanner is off
                  if:
                    - condition: template
                      value_template: |-
                        {{
                          ble_scanner_switch != ''
                          and is_state(ble_scanner_switch, 'off')
                        }}
                  then:
                    - alias: Turn on the BLE scanner
                      action: switch.turn_on
                      target:
                        entity_id: "{{ ble_scanner_switch }}"
                    - alias: Remember that the blueprint turned on the scanner
                      variables:
                        scanner_turned_on: true
            - alias: Wait for the location to be confirmed, the notification to be received, and the vehicle to be stopped
              wait_for_trigger:
                - alias: New position
                  id: position
                  trigger: event
                  event_type: state_changed
                  event_data:
                    entity_id: "{{ person }}"
                - alias: Notification received
                  trigger: event
                  id: notification_received
                  event_type: mobile_app_notification_received
                  event_data:
                    tag: "gps-request-{{this.attributes.id}}"
                  enabled: "{{ not ios_device }}"
                - alias: WiFi in range
                  trigger: template
                  id: wifi_in_range
                  value_template: |-
                    {{
                      states(wifi_devices[idx]) | is_number
                      or is_state(wifi_devices[idx], 'home')
                    }}
                  enabled: "{{ departure and wait_for_wifi }}"
                - alias: BLE in range
                  trigger: template
                  id: ble_in_range
                  value_template: |-
                    {{
                      states(ble_entities[idx]) | is_number
                      or is_state(ble_entities[idx], 'home')
                      or state_attr(ble_entities[idx], 'area_id') in gate_areas
                    }}
                  enabled: "{{ departure and wait_for_ble }}"
                - alias: Vehicle stopped
                  id: vehicle_stopped
                  trigger: template
                  value_template: "{{ is_state(driving_sensor, 'off') }}"
                - alias: Gates opened
                  trigger: template
                  id: gate_opened
                  value_template: *all_gates_open
                  enabled: "{{ not gates_were_opened }}"
                - alias: Gates closed
                  trigger: template
                  id: gate_closed
                  value_template: "{{ gate | select('is_state', ['off', 'closed', 'closing']) | list == gate }}"
                  enabled: "{{ gates_were_opened }}"
              timeout: |-
                {{
                  only_open_near_timeout
                  + start_timestamp
                  - now() | as_timestamp
                }}
            - alias: Refresh variables depending on the trigger
              choose:
                - alias: Triggered by a new GPS location
                  conditions:
                    - condition: template
                      value_template: "{{ wait.trigger.id == 'position' }}"
                  sequence:
                    - alias: Save the previous location
                      variables:
                        was_departure: "{{ departure }}"
                    - alias: Get whether the user is leaving or arriving
                      variables: *get_itinerary_mode
                    - alias: Get whether the user has entered the activation zone
                      variables:
                        entered_activation_zone: |-
                          {{
                            eta_zone and not departure
                            or (
                              wait.trigger.event.data.old_state.context.id != old_location_id
                              and arrival and was_departure
                            )
                          }}
                        gps_confirmed: true
                - alias: Triggered by the gate closing
                  conditions:
                    - condition: template
                      value_template: "{{ wait.trigger.id == 'gate_closed' }}"
                  sequence:
                    - alias: Get whether the gate was automatically closed
                      variables:
                        auto_closed: |-
                          {% set data = namespace(auto_closed=false) %}
                          {% for sensor in itinerary_sensors %}
                            {%
                              set value = (
                                states(sensor)
                                | from_json(default_itinerary_sensor_value)
                              )
                            %}
                            {%
                              if (
                                value.last_closed
                                | as_datetime
                                + timedelta(seconds=10)
                                > now()
                              )
                              and value.auto_closed
                            %}
                              {% set data.auto_closed = true %}
                              {% break %}
                            {% endif %}
                          {% endfor %}
                          {{ data.recently_closed and not data.auto_closed }}
            - choose:
                - alias: If the blueprint needs to stop
                  conditions:
                    - condition: template
                      value_template: |-
                        {{
                          wait.remaining == 0
                          or wait.trigger.id == 'vehicle_stopped'
                          or wait.trigger.id == 'position' and entered_activation_zone
                          or (
                            departure and (
                              wait.trigger.id == 'gate_closed' and not auto_closed
                              or lock_departure
                            )
                          )
                        }}
                  sequence:
                    - alias: Set the error id
                      variables:
                        message_id: |-
                          {% if wait.remaining == 0 %}
                            {%
                              if (
                                wait_for_gps
                                and not ios_device
                                and received_timestamp is not none
                                and (
                                  arrival
                                  or not wait_for_wifi and not wait_for_ble
                                )
                              )
                            %}
                              got_no_gps_data
                            {% else %}
                              {% if departure %}
                                not_home
                              {% else %}
                                location_not_confirmed
                              {% endif %}
                            {% endif %}
                          {% elif entered_activation_zone %}
                            too_close
                          {% elif departure and lock_departure %}
                            gate_closed
                          {% else %}
                            {{ wait.trigger.id }}
                          {% endif %}
                    - alias: If an error should be raised
                      if:
                        - condition: template
                          value_template: |-
                            {{
                              not departure
                              or behavior.departure.opening != 'off'
                              or behavior.departure.closing != 'off'
                            }}
                      then:
                        - alias: Create error
                          sequence: &create_error
                            - alias: Set title id
                              variables:
                                title_id: "itinerary_canceled"
                            - alias: If a notify service exists and the user should be notified
                              if:
                                - condition: template
                                  value_template: "{{ notify_service is not none and not silent_error }}"
                              then:
                                - alias: Get notification translation
                                  variables: *get_translation
                                - alias: Notify driver of itinerary cancelation
                                  action: "{{ notify_service }}"
                                  data:
                                    title: "{{ title }}"
                                    message: "{{ message }}"
                                    data: *notification_data
                                - sequence: *tts
                            - alias: Mark error in driver itinerary sensor
                              variables:
                                update:
                                  status: "{{ none }}"
                                  error: "{{ message_id }}"
                                itinerary_value: "{{ dict(itinerary_value, **update) }}"
                            - alias: Save the itinerary status
                              action: input_text.set_value
                              target:
                                entity_id: "{{ itinerary_sensor }}"
                              data:
                                value: "{{ itinerary_value | to_json }}"
                    - alias: Restore BLE devices
                      sequence: &restore_ble
                        - alias: If BLE devices were started
                          if:
                            - condition: template
                              value_template: "{{ ble_started }}"
                          then:
                            - alias: Restore iBeacon transmitter states
                              repeat:
                                for_each: "{{ ibeacon_restore_messages }}"
                                sequence:
                                  - alias: Send a notification to restore the iBeacon previous state
                                    action: "{{ notify_service }}"
                                    data: |-
                                      {{
                                        repeat.item
                                        | combine(
                                          {
                                            'data': {
                                              'importance': 'high',
                                              'priority':'high'
                                            }
                                          },
                                          recursive=True
                                        )
                                      }}
                            - alias: If the BLE scanner was turned on by the blueprint
                              if:
                                - condition: template
                                  value_template: "{{ scanner_turned_on }}"
                              then:
                                - alias: Turn off the BLE scanner
                                  action: switch.turn_off
                                  target:
                                    entity_id: "{{ ble_scanner_switch }}"
                        - alias: Check if there is another driver near the gate
                          variables:
                            someone_near_gate: |-
                              {% set data = namespace(result=false) %}
                              {% for sensor_idx in range(itinerary_sensors | length) %}
                                {% if sensor_idx != idx %}
                                  {%
                                    set value = (
                                      states(
                                        itinerary_sensors[sensor_idx]
                                      )
                                      | from_json(default_itinerary_sensor_value)
                                    )
                                  %}
                                  {% if value.status in ['on_approach', 'leaving'] %}
                                    {% set data.result = true %}
                                    {% break %}
                                  {% endif %}
                                {% endif %}
                              {% endfor %}
                              {{ data.result }}
                        - alias: If BLE scanner switch set, and doesn't need to stay on
                          if:
                            - condition: template
                              value_template: |-
                                {{
                                  ble_scanner_switch != ''
                                  and not someone_near_gate
                                }}
                          then:
                            - alias: Turn off BLE scanner
                              action: switch.turn_off
                              target:
                                entity_id: "{{ ble_scanner_switch }}"
                        - alias: Reset the ble_started variable
                          variables:
                            ble_started: false
                    - stop: The location was not confirmed
                - alias: If the notification was received
                  conditions:
                    - condition: template
                      value_template: "{{ wait.trigger.id == 'notification_received' }}"
                  sequence:
                    - alias: Save the timestamp of when the notification was received
                      variables:
                        received_timestamp: "{{ now() | as_timestamp }}"
                - alias: If someone opened all gates
                  conditions:
                    - condition: template
                      value_template: "{{ wait.trigger.id == 'gate_opened' }}"
                  sequence:
                    - alias: Now fait for the gates closing
                      variables:
                        gates_were_opened: true
                - alias: If someone manually closed all gate
                  conditions:
                    - condition: template
                      value_template: "{{ wait.trigger.id == 'gate_closed' and not auto_closed }}"
                  sequence:
                    - alias: Do not let the gates open on departure
                      variables:
                        lock_departure: true
  - alias: If BLE devices were started but are not needed anymore
    if:
      - condition: template
        value_template: |-
          {{
            ble_started and not (
              departure
              and 'ble' in close_when_disconnected_from
              and ble_entities | length > idx
            )
          }}
    then:
      - alias: Restore BLE devices
        sequence: *restore_ble
  - alias: If driver at gate location
    if:
      - condition: template
        value_template: "{{ is_state(person, [state_attr(gate_location, 'friendly_name'), states[gate_location].object_id]) }}"
    then:
      #####################
      # OPEN GATE ON EXIT #
      #####################

      - alias: Set the itinerary status to "leaving"
        variables:
          update:
            status: leaving
            error: "{{ none }}"
          itinerary_value: "{{ dict(itinerary_value, **update) }}"
      - alias: Save the itinerary status
        action: input_text.set_value
        target:
          entity_id: "{{ itinerary_sensor }}"
        data:
          value: "{{ itinerary_value | to_json }}"
      - alias: Set departure variables for the following sequence block
        variables:
          itinerary_mode: "departure"
          opening_message: "leaving_home"
          timeout_messages: |-
            {{
              dict(
                timeout_messages, **{
                  'safety_delay': 'did_not_leave'
                }
              )
            }}
      - if:
          - alias: If the user doesn't want his gate to open automatically if someone just closed it
            condition: template
            value_template: !input ask_reopen_manually_closed
          - alias: If the opening behavior is automatic
            condition: template
            value_template: "{{ behavior.departure.opening in ['timer', 'auto'] }}"
          - alias: If the gate was recently closed manually
            condition: template
            value_template: |-
              {%
                set data = namespace(
                  recently_closed=false,
                  auto_closed=false
                )
              %}
              {% for gate_entity in gate %}
                {%
                  if (
                    is_state(gate_entity, ['off', 'closed', 'closing'])
                    and states[gate_entity].last_updated
                      + timedelta(minutes=2)
                      > now()
                  )
                %}
                  {% set data.recently_closed = true %}
                  {% break %}
                {% endif %}
              {% endfor %}
              {% if data.recently_closed %}
                {% for sensor in itinerary_sensors %}
                  {%
                    set value = (
                      states(sensor)
                      | from_json(default_itinerary_sensor_value)
                    )
                  %}
                  {%
                    if (
                      value.last_closed
                      | as_datetime
                      + timedelta(minutes=2)
                      > now()
                    )
                    and value.auto_closed
                  %}
                    {% set data.auto_closed = true %}
                    {% break %}
                  {% endif %}
                {% endfor %}
              {% endif %}
              {{ data.recently_closed and not data.auto_closed }}
        then:
          - alias: Change the departure opening behavior to notificaiton request
            variables:
              behavior: |-
                {{
                  behavior
                  | combine(
                    {'departure': {'opening': 'notif'}},
                    recursive=True
                  )
                }}
      - alias: Open and close gate by following behaviors set by the user
        sequence: &open_close_behavior
          - alias: Get the opening/closing behaviors
            variables:
              opening_behavior: "{{ behavior[itinerary_mode].opening }}"
              closing_behavior: "{{ behavior[itinerary_mode].closing }}"
          - alias: If one of the gates is closed
            if:
              - condition: template
                value_template: &gate_closed |-
                  {{
                    gate
                    | select('is_state', ['off', 'closed', 'closing'])
                    | list
                    != []
                  }}
            then:
              - alias: Initialize a variable to wait for the phone to receive the notification before starting the timer
                variables:
                  wait_notif_reception: "{{ not ios_device and opening_behavior == 'timer' }}"
              - alias: If opening behavior is set to cancelable timer or notification request
                if:
                  - condition: template
                    value_template: "{{ opening_behavior in ['timer', 'notif'] }}"
                then:
                  - alias: Get button translation
                    variables: &get_button_translations
                      button_ids:
                        - "open"
                        - "cancel"
                      buttons: |-
                        {% set data = namespace(buttons=[]) %}
                        {% for button_id in button_ids %}
                          {# Custom translation #}
                          {%
                            if 'button' in custom_translations
                            and button_id in custom_translations['button']
                          %}
                            {% set translation = custom_translations['button'][button_id] %}

                          {# Selected language #}
                          {% elif button_id in strings[language]['button'] %}
                            {% set translation = strings[language]['button'][button_id] %}

                          {# Fallback to english #}
                          {% else %}
                            {% set translation = strings['en']['button'][button_id] %}
                          {% endif %}

                          {% set data.buttons = data.buttons + [translation] %}

                        {% endfor %}
                        {{ data.buttons }}
                  - alias: Build notification actions
                    variables:
                      opening_action:
                        action: "{{ opening_order_id }}"
                        title: "{{ buttons[0] }}"
                        icon: sfsymbols:lock.open
                      canceling_action:
                        action: "{{ canceling_order_id }}"
                        title: "{{ buttons[1] }}"
                        icon: sfsymbols:xmark
                  - choose:
                      - alias: If opening behavior is set to cancelable timer
                        conditions:
                          - condition: template
                            value_template: "{{ opening_behavior == 'timer' }}"
                        sequence:
                          - alias: Set title id
                            variables:
                              title_id: "timer_opening"
                          - alias: Format the notification
                            variables:
                              notification_data:
                                <<: *notification_data
                                notification_icon: mdi:timer-lock-open
                                sticky: true
                                persistent: true
                                confirmation: "{{ not ios_device }}"
                                timeout: "{{ timer_opening }}"
                                chronometer: true
                                when: "{{ timer_opening }}"
                                when_relative: true
                                actions:
                                  - "{{ canceling_action }}"
                                  - "{{ opening_action }}"
                      - alias: If opening behavior is set to notification request
                        conditions:
                          - condition: template
                            value_template: "{{ opening_behavior == 'notif' }}"
                        sequence:
                          - alias: Set title id
                            variables:
                              title_id: "open_gate"
                          - alias: Format the notification
                            variables:
                              notification_data:
                                <<: *notification_data
                                notification_icon: mdi:lock-question
                                sticky: true
                                persistent: true
                                actions:
                                  - "{{ opening_action }}"
                                  - "{{ canceling_action }}"
                  - alias: Set message id
                    variables:
                      message_id: "{{ opening_message }}"
                  - alias: Get notification translation
                    variables: *get_translation
                  - alias: Send the timer notification or opening request
                    action: "{{ notify_service }}"
                    data:
                      title: "{{ title }}"
                      message: "{{ message }}"
                      data: "{{ notification_data }}"
                  - sequence: *tts
              - alias: If opening behavior is not set to full auto
                if:
                  - condition: template
                    value_template: "{{ opening_behavior != 'auto' }}"
                then:
                  - alias: Listen for events a second time if the first event was a notification received confirmation
                    repeat:
                      until:
                        - condition: template
                          value_template: "{{ wait.trigger.id != 'notification_received' or opening_behavior == 'off' }}"
                      sequence:
                        - alias: Wait for events before opening the gate or canceling the itinerary
                          wait_for_trigger:
                            - alias: Manual opening
                              trigger: template
                              id: manual
                              value_template: *gate_open
                            - alias: Vehicle left
                              trigger: template
                              id: vehicle_stopped
                              value_template: "{{ is_state(driving_sensor, 'off') }}"
                            - alias: Vehicle restarted
                              trigger: template
                              id: vehicle_restarted
                              value_template: "{{ is_state(driving_sensor, 'on') }}"
                            - alias: Activation zone left
                              trigger: template
                              id: vehicle_away
                              value_template: &activation_zone_out_trigger |-
                                {% if state_attr(person, 'gps_accuracy') is none %}
                                  {% set accuracy = 100 %}
                                {% else %}
                                  {% set accuracy = state_attr(person, 'gps_accuracy') %}
                                {% endif %}
                                {% set gate_distance = distance(person, gate_location)*1000 - accuracy %}

                                {{ gate_distance > activation_zone }}
                            - alias: Forbidden zone entered
                              trigger: template
                              id: forbidden_zone
                              value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                            - alias: Opening button pressed
                              trigger: event
                              id: opening_order
                              event_type: mobile_app_notification_action
                              event_data:
                                action: "{{ opening_order_id }}"
                            - alias: Canceling button pressed
                              trigger: event
                              id: canceling_order
                              event_type: mobile_app_notification_action
                              event_data:
                                action: "{{ canceling_order_id }}"
                            - alias: Notification received
                              trigger: event
                              id: notification_received
                              event_type: mobile_app_notification_received
                              event_data:
                                action_2_key: "{{ opening_order_id }}"
                              enabled: "{{ wait_notif_reception }}"
                          timeout: |-
                            {% if opening_behavior == 'timer' %}
                              {{ timer_opening }}
                            {% else %}
                              2147483647
                            {% endif %}
                        - choose:
                            - alias: If the timer ran out but not in timer mode
                              conditions:
                                - condition: template
                                  value_template: |-
                                    {{
                                      wait.remaining == 0
                                      and opening_behavior != 'timer'
                                    }}
                              sequence:
                                - stop: This timer shouldn't reach zero !
                                  error: true
                            - alias: If the notification was received
                              conditions:
                                - condition: template
                                  value_template: "{{ wait.trigger.id == 'notification_received' }}"
                              sequence:
                                - alias: Stop waiting for notification reception
                                  variables:
                                    wait_notif_reception: false
                            - alias: If an error needs to be raised
                              conditions:
                                - condition: template
                                  value_template: "{{ wait.trigger.id in ['vehicle_stopped', 'vehicle_away', 'forbidden_zone', 'canceling_order'] }}"
                              sequence:
                                - alias: Set error id
                                  variables:
                                    message_id: "{{ wait.trigger.id }}"
                                - alias: Send a silent error if the behavior is set to off
                                  variables:
                                    silent_error: "{{ opening_behavior == 'off' }}"
                                - alias: Create error
                                  sequence: *create_error
                                - alias: Restore BLE devices
                                  sequence: *restore_ble
                                - stop: Opening canceled
                            - alias: If the opening behavior is set to notif or timer
                              conditions:
                                - condition: template
                                  value_template: "{{ opening_behavior in ['timer', 'notif'] }}"
                              sequence:
                                - alias: Remove opening notification
                                  action: "{{ notify_service }}"
                                  data: &clear_notification
                                    message: clear_notification
                                    data:
                                      tag: itinerary-status
              - alias: If opening behavior is not set to off
                if:
                  - condition: template
                    value_template: "{{ opening_behavior != 'off' }}"
                then:
                  - alias: Open each gate because driver is leaving
                    repeat: *open_gates
          - alias: Set an empty trigger id
            variables: &reset_trigger_id
              wait:
                trigger:
                  id: "{{ none }}"
          - alias: If one of the gates is open
            if:
              - condition: template
                value_template: *gate_open
            then:
              - alias: If BLE devices are needed to close the gate
                if:
                  - condition: template
                    value_template: |-
                      {{
                        'ble' in close_when_disconnected_from
                        and ble_entities | length > idx
                      }}
                then: *start_ble
              - alias: Set variables for the following repeat sequence
                variables:
                  break: "{{ closing_behavior in ['auto', 'off'] }}"
                  suggest_closing: |-
                    {{
                      closing_behavior == 'notif'
                      and itinerary_mode == 'departure'
                      and 'ble' not in close_when_disconnected_from
                    }}
                  wait_trigger_start: "{{ now() | as_timestamp }}"
                  wait_notif_reception: "{{ not ios_device and closing_behavior == 'timer' }}"
                  timer_reset_timestamp: "{{ none }}"
              - alias: Wait for events at least once, then while the gate closing has not been triggered
                repeat:
                  until: "{{ break }}"
                  sequence:
                    - alias: Set the timeout
                      variables:
                        timeout_type: |-
                          {% if repeat.first %}
                            {% if suggest_closing %}
                              closing_suggestion
                            {% else %}
                              safety_delay
                            {% endif %}
                          {% else %}
                            {% if closing_behavior == 'timer' %}
                              timer
                            {% else %}
                              {% if security_notif_override %}
                                safety_delay
                              {% else %}
                                default
                              {% endif %}
                            {% endif %}
                          {% endif %}
                        trigger_timeout: |-
                          {% if timeout_type == 'safety_delay' %}
                            {% set start_time = wait_trigger_start %}
                          {% elif timer_reset_timestamp is not none %}
                            {% set start_time = timer_reset_timestamp %}
                          {% else %}
                            {% set start_time = none %}
                          {% endif %}
                          {%
                            set remaining_timeout = timeouts[timeout_type]
                          %}
                          {% if start_time is not none %}
                            {% set remaining_timeout = (
                                remaining_timeout
                                + start_time
                                - now() | as_timestamp
                              )
                            %}
                          {% endif %}
                          {{ max(remaining_timeout, 0) }}
                    - alias: Wait for events before closing the gate
                      wait_for_trigger:
                        - alias: Manual closing
                          trigger: template
                          id: manual
                          value_template: *gate_closed
                        - alias: BLE out of reach
                          trigger: template
                          id: ble_out_of_range
                          value_template: |-
                            {{
                              is_state(ble_entities[idx], ['unknown', 'not_home'])
                              or (
                                ble_entities[idx] in states
                                and 'area_id' in states[ble_entities[idx]].attributes
                                and state_attr(ble_entities[idx], 'area_id') is none
                              )
                            }}
                          enabled: |-
                            {{
                              itinerary_mode == 'departure'
                              'ble' in close_when_disconnected_from
                              and idx < ble_entities | length
                            }}
                          for: !input ble_away_timeout
                        - alias: Vehicle left
                          trigger: template
                          id: vehicle_stopped
                          value_template: "{{ is_state(driving_sensor, 'off') }}"
                        - alias: Vehicle restarted
                          trigger: template
                          id: vehicle_restarted
                          value_template: "{{ is_state(driving_sensor, 'on') }}"
                        - alias: Activation zone left
                          trigger: template
                          id: vehicle_away
                          value_template: *activation_zone_out_trigger
                        - alias: Forbidden zone
                          trigger: template
                          id: forbidden_zone
                          value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                        - alias: Closing button pressed
                          trigger: event
                          id: closing_order
                          event_type: mobile_app_notification_action
                          event_data:
                            action: "{{ closing_order_id }}"
                        - alias: Canceling button pressed
                          trigger: event
                          id: canceling_order
                          event_type: mobile_app_notification_action
                          event_data:
                            action: "{{ canceling_order_id }}"
                        - alias: Notification received
                          trigger: event
                          id: notification_received
                          event_type: mobile_app_notification_received
                          event_data:
                            action_2_key: "{{ closing_order_id }}"
                          enabled: "{{ wait_notif_reception }}"
                      timeout:
                        seconds: "{{ trigger_timeout }}"
                    - alias: If the notification was received
                      if:
                        - condition: template
                          value_template: "{{ wait.trigger.id == 'notification_received' }}"
                      then:
                        - alias: Stop waiting for notification reception and reset the timer
                          variables:
                            wait_notif_reception: false
                            timer_reset_timestamp: "{{ now() | as_timestamp }}"
                      else:
                        - choose:
                            - alias: If the trigger needs to close the gate
                              conditions:
                                - condition: template
                                  value_template: |-
                                    {{
                                      wait.trigger.id in ['manual', 'closing_order']
                                      or (
                                        wait.remaining == 0
                                        and timeout_type == 'timer'
                                      )
                                    }}
                              sequence:
                                - alias: Break the loop next time
                                  variables:
                                    break: true
                            - alias: If a safety feature needs to change the closing behavior from notif to timer
                              conditions:
                                - condition: template
                                  value_template: |-
                                    {{
                                      security_notif_override
                                      and closing_behavior == 'notif'
                                      and (
                                        wait.remaining == 0
                                          and timeout_type == 'safety_delay'
                                        or wait.trigger.id in [
                                          'vehicle_stopped',
                                          'vehicle_away',
                                          'forbidden_zone',
                                        ]
                                      )
                                    }}
                              sequence:
                                - alias: Change closing behavior to timer
                                  variables:
                                    closing_behavior: "timer"
                                    timer_reset_timestamp: "{{ now() | as_timestamp }}"
                        - choose:
                            - alias: If this is the first loop
                              conditions:
                                - condition: template
                                  value_template: "{{ repeat.first }}"
                              sequence:
                                - alias: If the user is leaving
                                  if:
                                    - condition: template
                                      value_template: "{{ itinerary_mode == 'departure' }}"
                                  then:
                                    - alias: Restore BLE devices
                                      sequence: *restore_ble
                                - alias: Set message id
                                  variables:
                                    message_id: |-
                                      {% if wait.remaining == 0 %}
                                        {{ timeout_messages[timeout_type] }}
                                      {% elif wait.trigger.id in ['manual', 'closing_order'] %}
                                        {{ none }}
                                      {%
                                        elif wait.trigger.id == 'vehicle_stopped'
                                        and itinerary_mode == 'arrival'
                                      %}
                                        arrived
                                      {% else %}
                                        {{ wait.trigger.id }}
                                      {% endif %}
                                - alias: If a closing notification needs to be sent
                                  if:
                                    - condition: template
                                      value_template: "{{ not break }}"
                                  then:
                                    - alias: Get button translation
                                      variables:
                                        button_ids:
                                          - "close"
                                          - "cancel"
                                        <<: *get_button_translations
                                    - alias: Build notification actions
                                      variables:
                                        closing_action:
                                          action: "{{ closing_order_id }}"
                                          title: "{{ buttons[0] }}"
                                          icon: sfsymbols:lock
                                        canceling_action:
                                          action: "{{ canceling_order_id }}"
                                          title: "{{ buttons[1] }}"
                                          icon: sfsymbols:xmark
                                    - choose:
                                        - alias: If closing behavior is set to cancelable timer
                                          conditions:
                                            - condition: template
                                              value_template: "{{ closing_behavior == 'timer' }}"
                                          sequence:
                                            - alias: Set title id
                                              variables:
                                                title_id: "timer_closing"
                                            - alias: Format the notification
                                              variables:
                                                notification_data:
                                                  <<: *notification_data
                                                  notification_icon: mdi:lock-question
                                                  sticky: true
                                                  persistent: true
                                                  confirmation: "{{ not ios_device }}"
                                                  timeout: "{{ timer_closing }}"
                                                  chronometer: true
                                                  when: "{{ timer_closing }}"
                                                  when_relative: true
                                                  actions:
                                                    - "{{ canceling_action }}"
                                                    - "{{ closing_action }}"
                                        - alias: If closing behavior is set to notification request
                                          conditions:
                                            - condition: template
                                              value_template: "{{ closing_behavior == 'notif' }}"
                                          sequence:
                                            - alias: Set title id
                                              variables:
                                                title_id: "close_gate"
                                            - alias: Format the notification
                                              variables:
                                                notification_data:
                                                  <<: *notification_data
                                                  notification_icon: mdi:lock-question
                                                  sticky: true
                                                  persistent: true
                                                  actions:
                                                    - "{{ closing_action }}"
                                                    - "{{ canceling_action }}"
                                    - alias: Get notification translation
                                      variables: *get_translation
                                    - alias: Send the timer notification or closing request
                                      action: "{{ notify_service }}"
                                      data:
                                        title: "{{ title }}"
                                        message: "{{ message }}"
                                        data: "{{ notification_data }}"
                                    - sequence: *tts
                            - alias: If the itinerary needs to be canceled
                              conditions:
                                - condition: template
                                  value_template: "{{ wait.trigger.id == 'canceling_order' }}"
                              sequence:
                                - alias: Set error id
                                  variables:
                                    message_id: "canceling_order"
                                - alias: Create error
                                  sequence: *create_error
                                - stop: Closing canceled
                            - alias: If the vehicle was restarted
                              conditions:
                                - condition: template
                                  value_template: "{{ wait.trigger.id == 'vehicle_restarted' }}"
                              sequence:
                                - stop: Letting the new instance take over
          - alias: If a notification needs to be cleared
            if:
              - condition: template
                value_template: |-
                  {{
                    closing_behavior in ['timer', 'notif']
                    or (
                      itinerary_mode == 'arrival'
                      and itinerary_started_notif
                      and opening_behavior not in ['timer', 'notif']
                    )
                  }}
            then:
              - alias: Remove closing notification
                action: "{{ notify_service }}"
                data: *clear_notification
          - alias: If gate not closed manually
            if:
              - condition: template
                value_template: "{{ wait.trigger.id != 'manual' }}"
            then:
              - alias: Update the last closed variable
                variables:
                  update:
                    last_closed: "{{ now() | as_timestamp | int }}"
                    auto_closed: "{{ wait.trigger.id != 'closing_order' }}"
                  itinerary_value: "{{ dict(itinerary_value, **update) }}"
              - alias: If gate closing is enabled
                if:
                  - condition: template
                    value_template: "{{ closing_behavior != 'off' }}"
                then:
                  - alias: Get other drivers near the gate
                    variables:
                      drivers_near_gate: |-
                        {% set data = namespace(drivers_near_gate=[]) %}
                        {% for sensor_idx in range(itinerary_sensors | length) %}
                          {% if sensor_idx != idx %}
                            {%
                              set value = (
                                states(
                                  itinerary_sensors[sensor_idx]
                                )
                                | from_json(default_itinerary_sensor_value)
                              )
                            %}
                            {% if value.status in ['on_approach', 'leaving'] %}
                              {% if sensor_idx < persons | length %}
                                {% set name_sensor = persons[sensor_idx] %}
                              {% else %}
                                {% set name_sensor = itinerary_sensors[sensor_idx] %}
                              {% endif %}
                              {%
                                set data.drivers_near_gate = data.drivers_near_gate + [
                                  state_attr(name_sensor, 'friendly_name')
                                ]
                              %}
                            {% endif %}
                          {% endif %}
                        {% endfor %}
                        {{ data.drivers_near_gate }}
                  - alias: If someone is currently approaching or leaving
                    if:
                      - condition: template
                        value_template: "{{ drivers_near_gate != [] }}"
                      - condition: template
                        value_template: *gate_open
                    then:
                      - alias: Format drivers near gate as a string
                        variables:
                          awaited_persons: "{{ drivers_near_gate | join(', ') }}"
                      - alias: Set notification ids
                        variables:
                          title_id: "awaiting"
                          message_id: "awaiting"
                      - alias: Get notification translation
                        variables: *get_translation
                      - alias: If a notify service exists
                        if:
                          - condition: template
                            value_template: "{{ notify_service is not none }}"
                        then:
                          - alias: Notify driver that gate will wait for next person
                            action: "{{ notify_service }}"
                            data:
                              title: "{{ title }}"
                              message: "{{ message }}"
                              data:
                                <<: *notification_data
                                notification_icon: mdi:sleep
                          - sequence: *tts
                      - alias: Wait for gate closed
                        wait_for_trigger:
                          - trigger: template
                            value_template: *gate_closed
                      - alias: If a notify service exists
                        if:
                          - condition: template
                            value_template: "{{ notify_service is not none }}"
                        then:
                          - alias: Remove awaiting user notification
                            action: "{{ notify_service }}"
                            data: *clear_notification
                    else:
                      - alias: If an error needs to be raised
                        if:
                          - condition: template
                            value_template: |-
                              {{
                                closing_behavior == 'auto'
                                and message_id is not none
                                and message_id != 'arrived'
                              }}
                        then:
                          - alias: Create error
                            sequence: *create_error
                      - alias: Close all gates
                        repeat:
                          for_each: |-
                            {{
                              gate
                              | select('is_state', ['on', 'open', 'opening'])
                              | list
                            }}
                          sequence:
                            - action: |-
                                {% if states[repeat.item].domain == 'switch' %}
                                  switch.turn_off
                                {% elif states[repeat.item].domain == 'cover' %}
                                  cover.close_cover
                                {% endif %}
                              target:
                                entity_id: "{{ repeat.item }}"
          - alias: If the driver is leaving or has arrived home
            if:
              - condition: or
                conditions:
                  - condition: template
                    value_template: "{{ itinerary_mode == 'departure' }}"
                  - condition: template
                    value_template: *activation_zone_in_condition
            then:
              - alias: Set lock action prefix
                variables:
                  prefix: "{{ '' if itinerary_mode == 'departure' else 'un' }}"
              - alias: Do not lock if dont_lock_if_people_remaining is true and someone else is home
                if:
                  - condition: template
                    value_template: |-
                      {{
                        prefix == 'un'
                        or not dont_lock_if_people_remaining
                        or not expand(gate_location)
                          | map(attribute='entity_id')
                          | list
                          | difference([person])
                      }}
                then:
                  - alias: For each lock
                    repeat:
                      for_each: !input locks
                      sequence:
                        - alias: Unlock or lock the lock
                          action: "lock.{{ prefix }}lock"
                          target:
                            entity_id: "{{ repeat.item }}"
                        - alias: If the door should unlatch
                          if:
                            - condition: template
                              value_template: !input unlatch_doors
                            - condition: template
                              value_template: |-
                                {{
                                  prefix == 'un'
                                  and (
                                    state_attr(repeat.item, 'supported_features')
                                    | bitwise_and(1) == 1
                                  )
                                }}
                          then:
                            - alias: Unlatch the door
                              action: lock.open
                              target:
                                entity_id: "{{ repeat.item }}"
          - alias: Reset the itinerary status
            variables:
              update:
                status: "{{ none }}"
              itinerary_value: "{{ dict(itinerary_value, **update) }}"
          - alias: Save the itinerary status
            action: input_text.set_value
            target:
              entity_id: "{{ itinerary_sensor }}"
            data:
              value: "{{ itinerary_value | to_json }}"
      - alias: If the driver is not driving anyomore
        if:
          - condition: template
            value_template: "{{ is_state(driving_sensor, 'off') }}"
        then:
          - stop: Stopped driving
      - alias: Wait for driver to travel 250m away from activation zone, then return, to start itinerary
        repeat:
          count: 2
          sequence:
            - wait_for_trigger:
                - trigger: template
                  id: vehicle_stopped
                  value_template: "{{ is_state(driving_sensor, 'off') }}"
                - trigger: template
                  value_template: |-
                    {% if state_attr(person, 'gps_accuracy') is none %}
                      {% set accuracy = 100 %}
                    {% else %}
                      {% set accuracy = state_attr(person, 'gps_accuracy') %}
                    {% endif %}
                    {% set gate_distance = distance(person, gate_location)*1000 - accuracy %}

                    {{ gate_distance > activation_zone + 250 }}
                - trigger: template
                  value_template: |-
                    {% if state_attr(person, 'gps_accuracy') is none %}
                      {% set accuracy = 100 %}
                    {% else %}
                      {% set accuracy = state_attr(person, 'gps_accuracy') %}
                    {% endif %}
                    {% set gate_distance = distance(person, gate_location)*1000 + accuracy %}

                    {{ gate_distance < activation_zone }}
            - alias: Don't continue if driver stopped vehicle
              if:
                - condition: template
                  value_template: "{{ wait.trigger.id == 'vehicle_stopped' }}"
              then:
                - stop: Arrived to destination

    else:
      - alias: Stop if driver started driving in activation zone
        if:
          - condition: template
            value_template: *activation_zone_in_condition
        then:
          - alias: Set error id
            variables:
              message_id: "too_close"
          - alias: Create error
            sequence: *create_error
          - stop: Started too close to home

  ###################
  # START ITINERARY #
  ###################

  - alias: Set the itinerary status to "arriving"
    variables:
      update:
        status: arriving
        error: "{{ none }}"
      itinerary_value: "{{ dict(itinerary_value, **update) }}"
  - alias: Save the itinerary status
    action: input_text.set_value
    target:
      entity_id: "{{ itinerary_sensor }}"
    data:
      value: "{{ itinerary_value | to_json }}"
  - alias: If a notify service exists and the user wants to be notified
    if:
      - condition: template
        value_template: |-
          {{
            notify_service is not none
            and itinerary_started_notif
          }}
    then:
      - alias: Set notification ids
        variables:
          title_id: "itinerary_started"
          message_id: "vehicle_started"
      - alias: Get notification translation
        variables: *get_translation
      - alias: Notify driver of itinerary start
        action: "{{ notify_service }}"
        data:
          title: "{{ title }}"
          message: "{{ message }}"
          data:
            <<: *notification_data
            notification_icon: mdi:map-check
      - sequence: *tts
  - alias: Repeat while driver still driving
    repeat:
      while:
        - condition: template
          value_template: "{{ is_state(driving_sensor, 'on') }}"
      sequence:
        - alias: Reset opening time variable
          variables:
            opening_time: "{{ none }}"
        - alias: Update travel time if expired and refresh rate set to "Continuously"
          if:
            - condition: template
              value_template: |-
                {{
                  travel_time_rate == 'continuous'
                  and travel_time_sensor is not none
                  and (
                    (
                      states[travel_time_sensor].last_updated
                      + timedelta(minutes=continuously_refresh_interval)
                    ) < now()
                  )
                }}
          then:
            - alias: Set variables for the following sequence
              variables:
                quick_update_trigger: "{{ continuously_refresh_interval * 60 - 30 }}"
                reset_after: "{{ continuously_refresh_interval * 120 }}"
            - sequence: &update_travel_time
                - alias: Stop if travel time sensor does not exist
                  if:
                    - condition: template
                      value_template: "{{ states[travel_time_sensor] is none }}"
                  then:
                    - alias: Set error id
                      variables:
                        message_id: "invalid_travel_time_sensor"
                    - alias: Create error
                      sequence: *create_error
                    - alias: Log error
                      action: system_log.write
                      data:
                        level: error
                        message: "{{ message }}"
                        logger: blueprints.etiennec78.automatic_gate
                    - stop: Travel time sensor does not exist
                      error: true
                - alias: Only update the travel time if it has not already been updated recently
                  if:
                    - condition: template
                      value_template: "{{ now() - states[travel_time_sensor].last_updated > timedelta(seconds=quick_update_trigger) }}"
                  then:
                    - alias: Update travel time
                      action: homeassistant.update_entity
                      target:
                        entity_id: "{{ travel_time_sensor }}"
                  else:
                    - alias: If the last quick update was a long time ago
                      if:
                        - condition: template
                          value_template: |-
                            {{
                              last_quick_tt_update is not none
                              and last_quick_tt_update + timedelta(seconds=reset_after) > now()
                            }}
                      then:
                        - alias: Note that the travel time sensor tried to update too quickly
                          variables:
                            quick_tt_updates: "{{ quick_tt_updates + 1 }}"
                      else:
                        - alias: Reset the quick travel time updates counter
                          variables:
                            quick_tt_updates: 1
                    - alias: Reset the last quick update variable
                      variables:
                        last_quick_tt_update: "{{ now() }}"
                    - alias: If 20 travel time updates were too quick
                      if:
                        - condition: template
                          value_template: "{{ quick_tt_updates > 20 }}"
                      then:
                        - alias: Mark error in driver itinerary sensor
                          variables:
                            update:
                              status: "{{ none }}"
                              error: updated_frequently
                            itinerary_value: "{{ dict(itinerary_value, **update) }}"
                        - alias: Save the itinerary status
                          action: input_text.set_value
                          target:
                            entity_id: "{{ itinerary_sensor }}"
                          data:
                            value: "{{ itinerary_value | to_json }}"
                        - alias: Set error id
                          variables:
                            message_id: "disabled_updated_frequently"
                        - alias: Get notification translation
                          variables: *get_translation
                        - alias: Disable the blueprint
                          sequence: *disable_blueprint
        - alias: Wait for new driver position or vehicle left
          wait_for_trigger:
            - trigger: event
              event_type: state_changed
              event_data:
                entity_id: "{{ person }}"
            - trigger: template
              value_template: "{{ is_state(driving_sensor, 'off') }}"
        - alias: Stop if the user is in a forbidden zone
          if:
            - condition: template
              value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
          then:
            - sequence: &forbidden_zone
                - alias: Set error id
                  variables:
                    message_id: "forbidden_zone"
                - alias: Create error
                  sequence: *create_error
                - stop: Forbidden zone
        - choose:
            - conditions:
                - condition: template
                  value_template: "{{ 'ble' in open_when_connected_to }}"
              sequence:
                - alias: Set an empty trigger id
                  variables: *reset_trigger_id
                - repeat:
                    while:
                      - alias: Still in the activation zone
                        condition: template
                        value_template: *activation_zone_in_condition
                      - alias: Still driving
                        condition: template
                        value_template: "{{ is_state(driving_sensor, 'on') }}"
                      - alias: Opening not triggered
                        condition: template
                        value_template: "{{ wait.trigger.id != 'ble_in_reach' }}"
                    sequence:
                      - alias: If this is the first loop and the driver has a BLE tracker
                        if:
                          - condition: template
                            value_template: "{{ repeat.first and ble_entities | length > idx }}"
                        then: *start_ble
                      - alias: Wait for new position, vehicle left, or reachable BLE device
                        wait_for_trigger:
                          - alias: New position
                            id: position
                            trigger: event
                            event_type: state_changed
                            event_data:
                              entity_id: "{{ person }}"
                          - alias: Vehicle stopped
                            id: vehicle_stopped
                            trigger: template
                            value_template: "{{ is_state(driving_sensor, 'off') }}"
                          - alias: reachable BLE device
                            trigger: template
                            id: ble_in_reach
                            value_template: |-
                              {{
                                states(ble_entities[idx]) | is_number
                                or is_state(ble_entities[idx], 'home')
                                or state_attr(ble_entities[idx], 'area_id') in gate_areas
                              }}
                      - alias: If BLE devices won't need to stay on
                        if:
                          - condition: or
                            conditions:
                              - alias: Triggered by vehicle stopped or reachable BLE device
                                condition: template
                                value_template: "{{ wait.trigger.id != 'position' }}"
                              - alias: Not in the activation zone
                                condition: not
                                conditions:
                                  - condition: template
                                    value_template: *activation_zone_in_condition
                              - alias: Is in a forbidden zone
                                condition: template
                                value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                        then:
                          - sequence: *restore_ble
                          - alias: Stop if the user is in a forbidden zone
                            if:
                              - condition: template
                                value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                            then: *forbidden_zone
          default:
            - alias: Repeat while driver in activation zone and still driving
              # This allows to update to a precise ETA even if a traffic jam appears near your gate
              # It will return to the previous loop if the driver has entered the radius but passed by
              repeat:
                while:
                  - alias: Still in the activation zone
                    condition: template
                    value_template: *activation_zone_in_condition
                  - alias: Still driving
                    condition: template
                    value_template: "{{ is_state(driving_sensor, 'on') }}"
                  - alias: Opening not triggered
                    condition: template
                    value_template: |-
                      {{
                        opening_time is none
                        or opening_time > as_timestamp(now())
                      }}
                sequence:
                  - alias: Set variables for the following sequence
                    variables:
                      quick_update_trigger: 1
                      reset_after: 20
                  - alias: If the travel time needs to be updated
                    if:
                      - condition: template
                        value_template: |-
                          {{
                            travel_time_rate in ['continuous', 'near-home']
                            or opening_time is none
                              and travel_time_rate == 'once'
                              and failed_updates < 20
                          }}
                    then:
                      - alias: Update travel time
                        sequence: *update_travel_time
                  - alias: If the travel time sensor is not unknown or unavailable
                    if:
                      - condition: template
                        value_template: "{{ states(travel_time_sensor) not in ['unknown', 'unavailable'] }}"
                    then:
                      - alias: Convert travel time to seconds
                        variables:
                          travel_time_duration: |-
                            {% if state_attr(travel_time_sensor, 'duration') is none %}
                              {{ state_attr(travel_time_sensor, 'duration') | float * 60 }}
                            {% elif is_state_attr(travel_time_sensor, 'unit_of_measurement', 'min') %}
                              {{ states(travel_time_sensor) | float * 60 }}
                            {% elif is_state_attr(travel_time_sensor, 'unit_of_measurement', 's') %}
                              {{ states(travel_time_sensor) | float }}
                            {% elif is_state_attr(travel_time_sensor, 'device_class', 'timestamp') %}
                              {{
                                states(travel_time_sensor) | as_timestamp
                                - states[travel_time_sensor].last_updated | as_timestamp
                              }}
                            {% else %}
                              unknown
                            {% endif %}
                      - alias: Stop if travel time integration is not supported
                        if:
                          - condition: template
                            value_template: "{{ travel_time_duration == 'unknown' }}"
                        then:
                          - alias: Set error id
                            variables:
                              message_id: "unsupported_tt_integration"
                          - alias: Create error
                            sequence: *create_error
                          - alias: Log error
                            action: system_log.write
                            data:
                              level: error
                              message: "{{ message }}"
                              logger: blueprints.etiennec78.automatic_gate
                          - stop: Travel time integration not supported
                            error: true
                      - alias: Only continue if the duration is positive
                        condition: template
                        value_template: "{{ travel_time_duration >= 0 }}"
                      - alias: Set the opening time
                        variables:
                          opening_time: |-
                            {{
                              states[travel_time_sensor].last_updated | as_timestamp
                                + travel_time_duration
                                - lead_time
                                - (timer_opening if behavior.arrival.opening == 'timer' else 0)
                            }}
                    else:
                      - alias: Add 1 to the failed updates counter
                        variables:
                          failed_updates: "{{ failed_updates + 1 }}"
                  - alias: Set a timer for the gate opening (or max int value if travel time sensor is unknown and no previous eta was stored)
                    variables:
                      seconds_before_opening: |-
                        {% if opening_time is none %}
                          2147483647
                        {% else %}
                          {{ opening_time - now() | as_timestamp }}
                        {% endif %}
                  - alias: If ETA in the future or no opening time could be set
                    if:
                      - condition: template
                        value_template: "{{ seconds_before_opening > 0 }}"
                    then:
                      - alias: Wait for ETA, travel time, new position, vehicle left, and cancel if deviced timed out
                        wait_for_trigger:
                          - trigger: event
                            event_type: state_changed
                            event_data:
                              entity_id: "{{ person }}"
                          - trigger: event
                            event_type: state_changed
                            event_data:
                              entity_id: "{{ travel_time_sensor }}"
                            enabled: "{{ travel_time_rate == 'listen' }}"
                          - trigger: template
                            value_template: "{{ is_state(driving_sensor, 'off') }}"
                        timeout:
                          seconds: |-
                            {% if travel_time_rate == 'once' %}
                              {{ seconds_before_opening }}
                            {% else %}
                              {{ min(timeout_delay*60, seconds_before_opening) }}
                            {% endif %}
                      - choose:
                          - alias: If timeout ran out of time (not because of eta reached)
                            conditions:
                              - condition: template
                                value_template: |-
                                  {{
                                    wait.remaining == 0
                                    and opening_time is not none
                                    and opening_time > now() | as_timestamp
                                  }}
                            sequence:
                              - alias: Set error id
                                variables:
                                  message_id: "timed_out"
                              - alias: Create error
                                sequence: *create_error
                              - stop: Timed out
                          - alias: Stop if the user is in a forbidden zone
                            conditions:
                              - condition: template
                                value_template: "{{ person in expand(forbidden_zones) | map(attribute='entity_id') | list }}"
                            sequence: *forbidden_zone
        - alias: Return to the previous loop if the gate should not open yet
          condition: template
          value_template: |-
            {{
              'ble' in open_when_connected_to
                and wait.trigger.id == 'ble_in_reach'
              or opening_time is not none
                and opening_time <= as_timestamp(now())
            }}
        - alias: Return to the previous loop if the user has left the the activation zone
          condition: template
          value_template: *activation_zone_in_condition
        - alias: Set the itinerary status to "on_approach"
          variables:
            update:
              status: on_approach
            itinerary_value: "{{ dict(itinerary_value, **update) }}"
        - alias: Save the itinerary status
          action: input_text.set_value
          target:
            entity_id: "{{ itinerary_sensor }}"
          data:
            value: "{{ itinerary_value | to_json }}"
        - alias: Set arrival variables for the following sequence block
          variables:
            itinerary_mode: "arrival"
            opening_message: "soon_arrived"
            timeout_messages: |-
              {{
                timeout_messages | combine({
                  'safety_delay': 'did_not_arrive'
                })
              }}
        - alias: Open and close gate by following behaviors set by the user
          sequence: *open_close_behavior
        - alias: Stop whole script as successful
          stop: Successful
  - alias: If vehicle left in gate zone and travel time was not updated
    if:
      condition: template
      value_template: |-
        {{
          is_state(person, [state_attr(gate_location, 'friendly_name'), states[gate_location].object_id])
          and travel_time_sensor is not none
          and opening_time is none
        }}
    then:
      - alias: Set error id
        variables:
          message_id: "travel_time_did_not_respond"
      - alias: Create error
        sequence: *create_error
      - alias: Log error
        action: system_log.write
        data:
          level: error
          message: "{{ message }}"
          logger: blueprints.etiennec78.automatic_gate
      - stop: Travel time did not respond
        error: true
    else:
      - alias: Set error id
        variables:
          message_id: "vehicle_stopped"
      - alias: Create error
        sequence: *create_error
# Run in parralel to let the automation start with multiple users driving simultaneously
mode: parallel
max: 10
